<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="schematron_xslt_abstracts" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;?xar XSLT?&gt;

&lt;!-- 
     OVERVIEW - iso_abstract_expand.xsl
     
	    This is a preprocessor for ISO Schematron, which implements abstract patterns. 
	    It also 
	       	* extracts a particular schema using an ID, where there are multiple 
	    schemas, such as when they are embedded in the same NVDL script 
	    	* experimentally, allows parameter recognition and substitution inside
	    	text as well as @context, @test, &amp; @select.
		
		
		This should be used after iso-dsdl-include.xsl and before the skeleton or
		meta-stylesheet (e.g. iso-svrl.xsl) . It only requires XSLT 1.
		 
		Each kind of inclusion can be turned off (or on) on the command line.
		 
--&gt;
&lt;!-- 
  VERSION INFORMATION
  2008-09-18 RJ
  		* move out param test from iso:schema template  to work with XSLT 1. (Noah Fontes)
  		
  2008-07-29 RJ 
  		* Create.  Pull out as distinct XSL in its own namespace from old iso_pre_pro.xsl
  		* Put everything in private namespace
  		* Rewrite replace_substring named template so that copyright is clear
  	
  2008-07-24 RJ
       * correct abstract patterns so for correct names: param/@name and
     param/@value
    
  2007-01-12  RJ 
     * Use ISO namespace
     * Use pattern/@id not  pattern/@name 
     * Add Oliver Becker's suggests from old Schematron-love-in list for &lt;copy&gt; 
     * Add XT -ism?
  2003 RJ
     * Original written for old namespace
     * http://www.topologi.com/resources/iso-pre-pro.xsl
--&gt;	
&lt;!--
 LEGAL INFORMATION
 
 Copyright (c) 2000-2008 Rick Jelliffe and Academia Sinica Computing Center, Taiwan

 This software is provided 'as-is', without any express or implied warranty. 
 In no event will the authors be held liable for any damages arising from 
 the use of this software.

 Permission is granted to anyone to use this software for any purpose, 
 including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not claim
 that you wrote the original software. If you use this software in a product, 
 an acknowledgment in the product documentation would be appreciated but is 
 not required.

 2. Altered source versions must be plainly marked as such, and must not be 
 misrepresented as being the original software.

 3. This notice may not be removed or altered from any source distribution.
--&gt;
&lt;xslt:stylesheet version="1.0" xmlns:xslt="http://www.w3.org/1999/XSL/Transform" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:iso="http://purl.oclc.org/dsdl/schematron"  
    xmlns:nvdl="http://purl.oclc.org/dsdl/nvdl"  
    
  
    xmlns:iae="http://www.schematron.com/namespace/iae" 
     
      &gt;
	
	&lt;xslt:param name="schema-id"&gt;&lt;/xslt:param&gt;
	
	
	&lt;!-- Driver for the mode --&gt;
	&lt;xsl:template match="/"&gt;
  		&lt;xsl:apply-templates select="." mode="iae:go" /&gt;
	&lt;/xsl:template&gt; 
	
	
	&lt;!-- ================================================================================== --&gt;
	&lt;!-- Normal processing rules                                                            --&gt;
	&lt;!-- ================================================================================== --&gt;
	&lt;!-- Output only the selected schema --&gt; 
	&lt;xslt:template match="iso:schema" &gt;
	    &lt;xsl:if test="string-length($schema-id) =0 or @id= $schema-id "&gt;
	    	&lt;xslt:copy&gt;
				&lt;xslt:copy-of select="@*" /&gt;
				&lt;xslt:apply-templates  mode="iae:go" /&gt; 
			&lt;/xslt:copy&gt;
		&lt;/xsl:if&gt;
	&lt;/xslt:template&gt;
	
 
	&lt;!-- Strip out any foreign elements above the Schematron schema .
		--&gt;
	&lt;xslt:template match="*[not(ancestor-or-self::iso:*)]"     mode="iae:go"  &gt;
	   &lt;xslt:apply-templates  mode="iae:go" /&gt;
	&lt;/xslt:template&gt;
	   
	
	&lt;!-- ================================================================================== --&gt;
	&lt;!-- Handle Schematron abstract pattern preprocessing                                   --&gt;
	&lt;!-- abstract-to-real calls
			do-pattern calls 
				macro-expand calls 
					multi-macro-expand
						replace-substring                                                   --&gt;
	&lt;!-- ================================================================================== --&gt;
	
	&lt;!--
		Abstract patterns allow you to say, for example
		
		&lt;pattern name="htmlTable" is-a="table"&gt;
			&lt;param name="row" value="html:tr"/&gt;
			&lt;param name="cell" value="html:td" /&gt;
			&lt;param name="table" value="html:table" /&gt;
		&lt;/pattern&gt;
		
		For a good introduction, see Uche Ogbujii's article for IBM DeveloperWorks
		"Discover the flexibility of Schematron abstract patterns"
		  http://www-128.ibm.com/developerworks/xml/library/x-stron.html
		However, note that ISO Schematron uses @name and @value attributes on
		the iso:param element, and @id not @name on the pattern element.
		
	--&gt;
	
	&lt;!-- Suppress declarations of abstract patterns --&gt;
	&lt;xslt:template match="iso:pattern[@abstract='true']"  mode="iae:go"  &gt;
		&lt;xslt:comment&gt;Suppressed abstract pattern &lt;xslt:value-of select="@id"/&gt; was here&lt;/xslt:comment&gt;	
	&lt;/xslt:template&gt; 
	
	
	&lt;!-- Suppress uses of abstract patterns --&gt;
	&lt;xslt:template match="iso:pattern[@is-a]"  mode="iae:go" &gt;
			
		&lt;xslt:comment&gt;Start pattern based on abstract &lt;xslt:value-of select="@is-a"/&gt;&lt;/xslt:comment&gt;
		
		&lt;xslt:call-template name="iae:abstract-to-real" &gt;
			&lt;xslt:with-param name="caller" select="@id" /&gt;
			&lt;xslt:with-param name="is-a" select="@is-a" /&gt;
		&lt;/xslt:call-template&gt;
			
	&lt;/xslt:template&gt;
	 
	 
	
	&lt;!-- output everything else unchanged --&gt;
	&lt;xslt:template match="*" priority="-1"  mode="iae:go" &gt;
	    &lt;xslt:copy&gt;
			&lt;xslt:copy-of select="@*" /&gt;
			&lt;xslt:apply-templates mode="iae:go"/&gt; 
		&lt;/xslt:copy&gt;
	&lt;/xslt:template&gt;
	
	&lt;!-- Templates for macro expansion of abstract patterns --&gt;
	&lt;!-- Sets up the initial conditions for the recursive call --&gt;
	&lt;xslt:template name="iae:macro-expand"&gt;
		&lt;xslt:param name="caller"/&gt;
		&lt;xslt:param name="text" /&gt;
		&lt;xslt:call-template name="iae:multi-macro-expand"&gt;
			&lt;xslt:with-param name="caller" select="$caller"/&gt;
			&lt;xslt:with-param name="text" select="$text"/&gt;
			&lt;xslt:with-param name="paramNumber" select="1"/&gt;
		&lt;/xslt:call-template&gt;
		
	&lt;/xslt:template&gt;
	
	&lt;!-- Template to replace the current parameter and then
	   recurse to replace subsequent parameters. --&gt;
	    
	&lt;xslt:template name="iae:multi-macro-expand"&gt;
		&lt;xslt:param name="caller"/&gt;
		&lt;xslt:param name="text" /&gt;
		&lt;xslt:param name="paramNumber" /&gt;

		
		&lt;xslt:choose&gt;
			&lt;xslt:when test="//iso:pattern[@id=$caller]/iso:param[ $paramNumber]"&gt;

				&lt;xslt:call-template name="iae:multi-macro-expand"&gt;
					&lt;xslt:with-param name="caller" select="$caller"/&gt;	
					&lt;xslt:with-param name="paramNumber" select="$paramNumber + 1"/&gt;		
					&lt;xslt:with-param name="text" &gt;
						&lt;xslt:call-template name="iae:replace-substring"&gt;
							&lt;xslt:with-param name="original" select="$text"/&gt;
							&lt;xslt:with-param name="substring"
							select="concat('$', //iso:pattern[@id=$caller]/iso:param[ $paramNumber ]/@name)"/&gt;
							&lt;xslt:with-param name="replacement"
								select="//iso:pattern[@id=$caller]/iso:param[ $paramNumber ]/@value"/&gt;			
						&lt;/xslt:call-template&gt;
					&lt;/xslt:with-param&gt;						
				&lt;/xslt:call-template&gt;
			&lt;/xslt:when&gt;
			&lt;xslt:otherwise&gt;&lt;xslt:value-of select="$text" /&gt;&lt;/xslt:otherwise&gt;		
		
		&lt;/xslt:choose&gt;
	&lt;/xslt:template&gt;
	
	
	&lt;!-- generate the real pattern from an abstract pattern + parameters--&gt;
	&lt;xslt:template name="iae:abstract-to-real" &gt;
		&lt;xslt:param name="caller"/&gt;
		&lt;xslt:param name="is-a" /&gt;
		&lt;xslt:for-each select="//iso:pattern[@id= $is-a]"&gt;
		&lt;xslt:copy&gt;
		
		    &lt;xslt:choose&gt;
		      &lt;xslt:when test=" string-length( $caller ) = 0"&gt;
		      &lt;xslt:attribute name="id"&gt;&lt;xslt:value-of select="concat( generate-id(.) , $is-a)" /&gt;&lt;/xslt:attribute&gt;
		      &lt;/xslt:when&gt;
		      &lt;xslt:otherwise&gt;
				&lt;xslt:attribute name="id"&gt;&lt;xslt:value-of select="$caller" /&gt;&lt;/xslt:attribute&gt;
		      &lt;/xslt:otherwise&gt;
		    &lt;/xslt:choose&gt; 
			
			&lt;xslt:apply-templates select="*|text()" mode="iae:do-pattern"    &gt;
				&lt;xslt:with-param name="caller"&gt;&lt;xslt:value-of select="$caller"/&gt;&lt;/xslt:with-param&gt;
			&lt;/xslt:apply-templates&gt;	
			
		&lt;/xslt:copy&gt;
		&lt;/xslt:for-each&gt;
	&lt;/xslt:template&gt;
		
	
	&lt;!-- Generate a non-abstract pattern --&gt;
	&lt;xslt:template mode="iae:do-pattern" match="*"&gt;
		&lt;xslt:param name="caller"/&gt;
		&lt;xslt:copy&gt;
			&lt;xslt:for-each select="@*[name()='test' or name()='context' or name()='select']"&gt;
				&lt;xslt:attribute name="{name()}"&gt;
				&lt;xslt:call-template name="iae:macro-expand"&gt;
						&lt;xslt:with-param name="text"&gt;&lt;xslt:value-of select="."/&gt;&lt;/xslt:with-param&gt;
						&lt;xslt:with-param name="caller"&gt;&lt;xslt:value-of select="$caller"/&gt;&lt;/xslt:with-param&gt;
					&lt;/xslt:call-template&gt;
				&lt;/xslt:attribute&gt;
			&lt;/xslt:for-each&gt;	
			&lt;xslt:copy-of select="@*[name()!='test'][name()!='context'][name()!='select']" /&gt;
			&lt;xsl:for-each select="node()"&gt;
				&lt;xsl:choose&gt;
				    &lt;!-- Experiment: replace macros in text as well, to allow parameterized assertions
				        and so on, without having to have spurious &lt;iso:value-of&gt; calls and multiple
				        delimiting --&gt;
					&lt;xsl:when test="self::text()"&gt;	
						&lt;xslt:call-template name="iae:macro-expand"&gt;
							&lt;xslt:with-param name="text"&gt;&lt;xslt:value-of select="."/&gt;&lt;/xslt:with-param&gt;
							&lt;xslt:with-param name="caller"&gt;&lt;xslt:value-of select="$caller"/&gt;&lt;/xslt:with-param&gt;
						&lt;/xslt:call-template&gt;
					&lt;/xsl:when&gt;
					&lt;xsl:otherwise&gt;
						&lt;xslt:apply-templates select="." mode="iae:do-pattern"&gt;
							&lt;xslt:with-param name="caller"&gt;&lt;xslt:value-of select="$caller"/&gt;&lt;/xslt:with-param&gt;
						&lt;/xslt:apply-templates&gt;		
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;
			&lt;/xsl:for-each&gt;			
		&lt;/xslt:copy&gt;
	&lt;/xslt:template&gt;
	
	&lt;!-- UTILITIES --&gt; 
	&lt;!-- Simple version of replace-substring function --&gt;
	&lt;xslt:template name="iae:replace-substring"&gt;
		&lt;xslt:param name="original" /&gt;    
		&lt;xslt:param name="substring" /&gt;   
		&lt;xslt:param name="replacement" select="''"/&gt;
		
  &lt;xsl:choose&gt;
    &lt;xsl:when test="not($original)" /&gt; 
    &lt;xsl:when test="not(string($substring))"&gt;
      &lt;xsl:value-of select="$original" /&gt;
    &lt;/xsl:when&gt; 
        &lt;xsl:when test="contains($original, $substring)"&gt;
          &lt;xsl:variable name="before" select="substring-before($original, $substring)" /&gt;
          &lt;xsl:variable name="after" select="substring-after($original, $substring)" /&gt;
          
          &lt;xsl:value-of select="$before" /&gt;
          &lt;xsl:value-of select="$replacement" /&gt;
          &lt;!-- recursion --&gt;
          &lt;xsl:call-template name="iae:replace-substring"&gt;
            &lt;xsl:with-param name="original" select="$after" /&gt;
            &lt;xsl:with-param name="substring" select="$substring" /&gt;
            &lt;xsl:with-param name="replacement" select="$replacement" /&gt; 
            &lt;/xsl:call-template&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
        	&lt;!-- no substitution --&gt;
        	&lt;xsl:value-of select="$original" /&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt; 
&lt;/xslt:template&gt;

&lt;/xslt:stylesheet&gt;</value>
    <comment>Schematron transform - step 2 of 3</comment>
  </data>
  <data name="schematron_xslt_includes" xml:space="preserve">
    <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;?xar XSLT?&gt;

&lt;!-- 
     OVERVIEW : iso_dsdl_include.xsl
     
	    This is an inclusion preprocessor for the non-smart text inclusions
	    of ISO DSDL. It handles 
	    	&lt;relax:extRef&gt; for ISO RELAX NG
	    	&lt;sch:include&gt;  for ISO Schematron and Schematron 1.n
	    	&lt;sch:extends&gt;  for 2009 draft ISO Schematron
	    	&lt;xi:xinclude&gt;  simple W3C XIncludes for ISO NVRL and DSRL 
	    	&lt;crdl:ref&gt;     for draft ISO CRDL
	    	&lt;dtll:include&gt; for draft ISO DTLL
	    	&lt;* @xlink:href&gt; for simple W3C XLink 1.1 embedded links
	    	
		 
		This should be the first in any chain of processing. It only requires
		XSLT 1. Each kind of inclusion can be turned off (or on) on the command line.
		
		Ids in fragment identifiers or xpointers will be sought in the following
		order:
		    * @xml:id
		    * id() for typed schemas (e.g. from DTD) [NOTE: XInclude does not support this]
		    * untyped @id 
		    
	The proposed behaviour for the update to ISO Schematron has been implemented. If an
	include points to an element with the same name as the parent, then that element's
	contents will be included. This supports the merge style of inclusion.    
	
	When an inclusion is made, it is preceded by a PI with target DSDL_INCLUDE_START
	and the href and closed by a PI with target DSDL_INCLUDE_START and the href. This is
	to allow better location of problems, though only to the file level. 
	
	Limitations:
	* No rebasing: relative paths will be interpreted based on the initial document's
	path, not the including document. (Severe limitation!)
	* No checking for circular references
	* Not full xpointers: only ID matching
	* &lt;relax:include&gt; not implemented 
	* XInclude handling of xml:base and xml:lang not implemented   
--&gt;
&lt;!-- 
  VERSION INFORMATION
	2009-02-25 
	* Update DSDL namespace to use schematron.com
	* Tested with SAXON9, Xalan 2.7.1, IE7, 
	* IE does not like multiple variables in same template with same name: rename.   
	2008-09-18
	* Remove new behaviour for include, because it conflicts with existing usage [KH]
	* Add extends[@href] element with that merge functionality
	* Generate PIs to notate source of inclusions for potential better diagnostics
	
	2008-09-16
	* Fix for XSLT1
	
	2008-08-28
	* New behaviour for schematron includes: if the pointed to element is the same as the current,
	include the children.
	
	2008-08-20
	* Fix bug: in XSLT1 cannot do $document/id('x') but need to use for-each
	
	2008-08-04
	* Add support for inclusions in old namespace  
	
	2008-08-03
	* Fix wrong param name include-relaxng &amp; include-crdl (KH, PH)
	* Allow inclusion of XSLT and XHTML (KH)
	* Fix inclusion of fragments (KH)
	
	2008-07-25
	* Add selectable input parameter
	
	2008-07-24  
	* RJ New
--&gt;
&lt;!--
	LEGAL INFORMATION
	
	Copyright (c) 2008 Rick Jelliffe 
	
	This software is provided 'as-is', without any express or implied warranty. 
	In no event will the authors be held liable for any damages arising from 
	the use of this software.
	
	Permission is granted to anyone to use this software for any purpose, 
	including commercial applications, and to alter it and redistribute it freely,
	subject to the following restrictions:
	
	1. The origin of this software must not be misrepresented; you must not claim
	that you wrote the original software. If you use this software in a product, 
	an acknowledgment in the product documentation would be appreciated but is 
	not required.
	
	2. Altered source versions must be plainly marked as such, and must not be 
	misrepresented as being the original software.
	
	3. This notice may not be removed or altered from any source distribution.
--&gt;
&lt;xslt:stylesheet version="1.0"
	xmlns:xslt="http://www.w3.org/1999/XSL/Transform"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:iso="http://purl.oclc.org/dsdl/schematron"
	xmlns:nvdl="http://purl.oclc.org/dsdl/nvdl"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"
	xmlns:schold="http://www.ascc.net/xml/schematron"
	xmlns:crdl="http://purl.oclc.org/dsdl/crepdl/ns/structure/1.0"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:dtll="http://www.jenitennison.com/datatypes"
	xmlns:dsdl="http://www.schematron.com/namespace/dsdl"
	xmlns:relax="http://relaxng.org/ns/structure/1.0"
	xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
	&lt;!-- Note: The URL for the dsdl namespace is not official --&gt;


	&lt;xsl:param name="include-schematron"&gt;true&lt;/xsl:param&gt;
	&lt;xsl:param name="include-crdl"&gt;true&lt;/xsl:param&gt;
	&lt;xsl:param name="include-xinclude"&gt;true&lt;/xsl:param&gt;
	&lt;xsl:param name="include-dtll"&gt;true&lt;/xsl:param&gt;
	&lt;xsl:param name="include-relaxng"&gt;true&lt;/xsl:param&gt;
	&lt;xsl:param name="include-xlink"&gt;true&lt;/xsl:param&gt;

	&lt;xsl:template match="/"&gt;
		&lt;xsl:apply-templates select="." mode="dsdl:go" /&gt;
	&lt;/xsl:template&gt;

	&lt;!-- output everything else unchanged --&gt;
	&lt;xslt:template match="node()" priority="-1" mode="dsdl:go"&gt;
		&lt;xslt:copy&gt;
			&lt;xslt:copy-of select="@*" /&gt;
			&lt;xslt:apply-templates mode="dsdl:go" /&gt;
		&lt;/xslt:copy&gt;
	&lt;/xslt:template&gt;



	&lt;!-- =========================================================== --&gt;
	&lt;!-- ISO/IEC 19757 - DSDL Document Schema Definition Languages   --&gt;
	&lt;!-- Part 2 - Regular grammar-based validation - RELAX NG        --&gt;
	&lt;!-- This only implements relax:extRef not relax:include which   --&gt;
	&lt;!-- is complex.                                                 --&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;xslt:template match="relax:extRef" mode="dsdl:go"&gt;


		&lt;!-- Insert subschema --&gt;

		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@href, '#')" /&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-relaxng = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;

				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in RELAX NG extRef
							include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;
						&lt;xslt:apply-templates mode="dsdl:go"
							select="//*[@xml:id= $fragment-id ] | id( $fragment-id) | //*[@id= $fragment-id ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;

						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use a for-each so that the id() function works correctly on the external document --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select="$theDocument_1//*[@xml:id= $fragment-id ]        
                  |  id( $fragment-id)          
              | $theDocument_1//*[@id= $fragment-id ]" /&gt;
							&lt;xsl:if test="not($theFragment_1)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:if&gt;
							&lt;xsl:apply-templates
								select=" $theFragment_1[1]" mode="dsdl:go" /&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/*" /&gt;
						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;xsl:if test="not($theFragment_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;xsl:apply-templates select="$theFragment_2 "
							mode="dsdl:go" /&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xslt:template&gt;



	&lt;!-- =========================================================== --&gt;
	&lt;!-- ISO/IEC 19757 - DSDL Document Schema Definition Languages   --&gt;
	&lt;!-- Part 3 - Rule-based validation - Schematron                 --&gt;
	&lt;!-- =========================================================== --&gt;


	&lt;!-- Extend the URI syntax to allow # references --&gt;
	&lt;!-- Add experimental support for simple containers like  /xxx:xxx/iso:pattern to allow better includes --&gt;
	&lt;xsl:template match="iso:include" mode="dsdl:go"&gt;

		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@href, '#')" /&gt;


		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;

		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-schematron = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;

				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in Schematron include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;
						&lt;xslt:apply-templates mode="dsdl:go"
							select="//iso:*[@xml:id= $fragment-id ] 
              	 |id( $fragment-id)
              	 | //iso:*[@id= $fragment-id ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;!-- case where there is a fragment in another document (should be an iso: element) --&gt;
					&lt;!-- There are three cases for includes with fragment:
						0) No href file or no matching id - error!
						1) REMOVED
						
						2) The linked-to element is sch:schema however the parent of the include
						is not a schema. In this case, it is an error. (Actually, it should
						be an error for other kinds of containment problems, but we won't
						check for them in this version.)
						
						3) Otherwise, include the pointed-to element
					--&gt;

					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="originalParent" select=".." /&gt;

						&lt;!-- case 0 --&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use for-each to rebase id() to external document --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select=" $theDocument_1//iso:*[@xml:id= $fragment-id ] |
              	 		id($fragment-id) |
              			$theDocument_1//iso:*[@id= $fragment-id ]" /&gt;


							&lt;xsl:choose&gt;
								&lt;!-- case 0 --&gt;
								&lt;xsl:when test="not($theFragment_1)"&gt;
									&lt;xsl:message terminate="no"&gt;
										&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
										&lt;xsl:value-of select="@href" /&gt;
									&lt;/xsl:message&gt;
								&lt;/xsl:when&gt;


								&lt;!-- case 1 REMOVED --&gt;

								&lt;!-- case 2 --&gt;
								&lt;xsl:when
									test=" $theFragment_1/self::iso:schema "&gt;
									&lt;xsl:message&gt;
										Schema error: Use include to
										include fragments, not a whole
										schema
									&lt;/xsl:message&gt;
								&lt;/xsl:when&gt;

								&lt;!-- case 3 --&gt;
								&lt;xsl:otherwise&gt;
									&lt;xsl:apply-templates
										select=" $theFragment_1[1]" mode="dsdl:go" /&gt;
								&lt;/xsl:otherwise&gt;
							&lt;/xsl:choose&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;!-- Case where there is no ID so we include the whole document --&gt;
					&lt;!-- Experimental addition: include fragments of children --&gt;
					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/iso:*" /&gt;
						&lt;xsl:variable name="theContainedFragments"
							select="$theDocument_2/*/iso:* | $theDocument_2/*/xsl:* | $theDocument_2/*/xhtml:*" /&gt;
						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;!-- There are three cases for includes:
							0) No text specified- error!
							
							1) REMOVED
							
							2) The linked-to element is sch:schema however the parent of the include
							is not a schema. In this case, it is an error. (Actually, it should
							be an error for other kinds of containment problems, but we won't
							check for them in this version.)
							
							3) Otherwise, include the pointed-to element
						--&gt;
						&lt;xsl:choose&gt;
							&lt;!-- case 0 --&gt;
							&lt;xsl:when
								test="not($theFragment_2) and not ($theContainedFragments)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:when&gt;

							&lt;!-- case 1 removed --&gt;

							&lt;!-- case 2 --&gt;
							&lt;xsl:when
								test=" $theFragment_2/self::iso:schema or $theContainedFragments/self::iso:schema"&gt;
								&lt;xsl:message&gt;
									Schema error: Use include to include
									fragments, not a whole schema
								&lt;/xsl:message&gt;
							&lt;/xsl:when&gt;

							&lt;!-- If this were XLST 2, we could use  
								if ($theFragment) then $theFragment else $theContainedFragments
								here (thanks to KN)
							--&gt;
							&lt;!-- case 3 --&gt;
							&lt;xsl:otherwise&gt;
								&lt;xsl:apply-templates
									select="$theFragment_2 " mode="dsdl:go" /&gt;
							&lt;/xsl:otherwise&gt;
						&lt;/xsl:choose&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;
			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xsl:template&gt;


	&lt;!-- WARNING   sch:extends[@href] is experimental and non standard  --&gt;
	&lt;!-- Basically, it adds the children of the selected element, not the element itself.  --&gt;
	&lt;xsl:template match="iso:extends[@href]" mode="dsdl:go"&gt;

		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@href, '#')" /&gt;


		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;

		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-schematron = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;

				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in Schematron include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;
						&lt;xslt:apply-templates mode="dsdl:go"
							select="//iso:*[@xml:id= $fragment-id ]/* 
              	 |id( $fragment-id)/*
              	 | //iso:*[@id= $fragment-id ]/*" /&gt;
					&lt;/xslt:when&gt;

					&lt;!-- case where there is a fragment in another document (should be an iso: element) --&gt;
					&lt;!-- There are three cases for includes with fragment:
						0) No href file or no matching id - error!
						1) REMOVED
						
						2) REMOVED
						
						3) Otherwise, include the pointed-to element
					--&gt;

					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="originalParent" select=".." /&gt;

						&lt;!-- case 0 --&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use for-each to rebase id() to external document --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select=" $theDocument_1//iso:*[@xml:id= $fragment-id ] |
              	 		id($fragment-id) |
              			$theDocument_1//iso:*[@id= $fragment-id ]" /&gt;


							&lt;xsl:choose&gt;
								&lt;!-- case 0 --&gt;
								&lt;xsl:when test="not($theFragment_1)"&gt;
									&lt;xsl:message terminate="no"&gt;
										&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
										&lt;xsl:value-of select="@href" /&gt;
									&lt;/xsl:message&gt;
								&lt;/xsl:when&gt;


								&lt;!-- case 1 REMOVED --&gt;

								&lt;!-- case 2 REMOVED --&gt;


								&lt;!-- case 3 --&gt;
								&lt;xsl:otherwise&gt;

									&lt;xsl:apply-templates
										select=" $theFragment_1[1]/*" mode="dsdl:go" /&gt;
								&lt;/xsl:otherwise&gt;
							&lt;/xsl:choose&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;!-- Case where there is no ID so we include the whole document --&gt;
					&lt;!-- Experimental addition: include fragments of children --&gt;
					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/iso:*" /&gt;
						&lt;xsl:variable name="theContainedFragments"
							select="$theDocument_2/*/iso:* | $theDocument_2/*/xsl:* | $theDocument_2/*/xhtml:*" /&gt;
						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;!-- There are three cases for includes:
							0) No text specified- error!
							
							1) REMOVED
							
							2) REMOVED
							
							3) Otherwise, include the pointed-to element
						--&gt;
						&lt;xsl:choose&gt;
							&lt;!-- case 0 --&gt;
							&lt;xsl:when
								test="not($theFragment_2) and not ($theContainedFragments)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:when&gt;

							&lt;!-- case 1 removed --&gt;

							&lt;!-- case 2 removed --&gt;

							&lt;!-- If this were XLST 2, we could use  
								if ($theFragment) then $theFragment else $theContainedFragments
								here (thanks to KN)
							--&gt;
							&lt;!-- case 3 --&gt;
							&lt;xsl:otherwise&gt;
								&lt;xsl:apply-templates
									select="$theFragment_2/* " mode="dsdl:go" /&gt;
							&lt;/xsl:otherwise&gt;
						&lt;/xsl:choose&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;
			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xsl:template&gt;



	&lt;!-- =========================================================== --&gt;
	&lt;!-- Handle Schematron 1.6 inclusions: clone of ISO code above   --&gt;
	&lt;!-- =========================================================== --&gt;


	&lt;!-- Extend the URI syntax to allow # references --&gt;
	&lt;!-- Add experimental support for simple containers like  /xxx:xxx/schold:pattern to allow better includes --&gt;
	&lt;xsl:template match="schold:include" mode="dsdl:go"&gt;
		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@href, '#')" /&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;

		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-schematron = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in Schematron include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;
						&lt;xslt:apply-templates mode="dsdl:go"
							select="//schold:*[@xml:id= $fragment-id ] 
              	 |id( $fragment-id)
              	 | //schold:*[@id= $fragment-id ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;!-- case where there is a fragment in another document (should be an iso: element) --&gt;
					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use for-each to rebase id() to $theDocument --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select=" $theDocument_1//schold:*[@xml:id= $fragment-id ] |
              	id($fragment-id) |
              	$theDocument_1//schold:*[@id= $fragment-id ]" /&gt;
							&lt;xsl:if
								test=" $theFragment_1/self::schold:schema "&gt;
								&lt;xsl:message&gt;
									Schema error: Use include to include
									fragments, not a whole schema
								&lt;/xsl:message&gt;
							&lt;/xsl:if&gt;
							&lt;xsl:if test="not($theFragment_1)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:if&gt;
							&lt;xsl:apply-templates
								select=" $theFragment_1[1]" mode="dsdl:go" /&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;!-- Case where there is no ID so we include the whole document --&gt;
					&lt;!-- Experimental addition: include fragments of children --&gt;
					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/iso:*" /&gt;
						&lt;xsl:variable name="theContainedFragments"
							select="$theDocument_2/*/schold:* | $theDocument_2/*/xsl:* | $theDocument_2/*/xhtml:*" /&gt;
						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;xsl:if
							test=" $theFragment_2/self::schold:schema or $theContainedFragments/self::schold:schema"&gt;
							&lt;xsl:message&gt;
								Schema error: Use include to include
								fragments, not a whole schema
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;xsl:if
							test="not($theFragment_2) and not ($theContainedFragments)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- If this were XLST 2, we could use  
							if ($theFragment) then $theFragment else $theContainedFragments
							here (thanks to KN)
						--&gt;
						&lt;xsl:choose&gt;
							&lt;xsl:when test=" $theFragment_2 "&gt;
								&lt;xsl:apply-templates
									select="$theFragment_2 " mode="dsdl:go" /&gt;
							&lt;/xsl:when&gt;
							&lt;xsl:otherwise&gt;
								&lt;!-- WARNING!  EXPERIMENTAL! Use at your own risk. This may be discontinued! --&gt;
								&lt;xsl:apply-templates
									select="  $theContainedFragments " mode="dsdl:go" /&gt;
							&lt;/xsl:otherwise&gt;
						&lt;/xsl:choose&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xsl:template&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;!-- ISO/IEC 19757 - DSDL Document Schema Definition Languages   --&gt;
	&lt;!-- Part 5 - DataType Library Language - DTLL                   --&gt;
	&lt;!-- Committee Draft  Experimental support only                  --&gt;
	&lt;!-- The &lt;include&gt; element may well be replaced by XInclude in   --&gt;
	&lt;!-- any final version.                                          --&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;xslt:template match="dtll:include" mode="dsdl:go"&gt;
		&lt;!-- Insert subschema --&gt;

		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@href, '#')" /&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-dtll = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in DTLL include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;
						&lt;xslt:apply-templates mode="dsdl:go"
							select="//*[@xml:id= $fragment-id ] | id( $fragment-id) 
              	| //*[@id= $fragment-id ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use for-each to rebase id() to $theDocument --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select="$theDocument_1//*[@xml:id= $fragment-id ]
               | id( $fragment-id ) 
               | $theDocument_1//*[@id= $fragment-id ]" /&gt;
							&lt;xsl:if test="not($theFragment_1)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:if&gt;
							&lt;xsl:apply-templates
								select=" $theFragment_1[1]" mode="dsdl:go" /&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/*" /&gt;

						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;xsl:if test="not($theFragment_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;xsl:apply-templates select="$theFragment_2 "
							mode="dsdl:go" /&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xslt:template&gt;

	&lt;!-- =========================================================== --&gt;
	&lt;!-- ISO/IEC 19757 - DSDL Document Schema Definition Languages   --&gt;
	&lt;!-- Part 7 - Character Repertoire Description Language - CRDL   --&gt;
	&lt;!-- Final Committee Draft 2008-01-11 Experimental support only  --&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;xslt:template match="crdl:ref" mode="dsdl:go"&gt;
		&lt;!-- Insert subschema --&gt;

		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@href, '#')" /&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-crdl = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in CRDL include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;

						&lt;xslt:apply-templates mode="dsdl:go"
							select="//*[@xml:id= $fragment-id ] | id( $fragment-id)
              	| //*[@id= $fragment-id ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use for-each to rebase id() to $theDocument --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select="$theDocument_1//*[@xml:id= $fragment-id ]
               | id( $fragment-id )
               | $theDocument_1//*[@id= $fragment-id ]" /&gt;

							&lt;xsl:if test="not($theFragment_1)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:if&gt;
							&lt;xsl:apply-templates select=" $theFragment_1 "
								mode="dsdl:go" /&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/*" /&gt;

						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;xsl:if test="not($theFragment_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;xsl:apply-templates select="$theFragment_2"
							mode="dsdl:go" /&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xslt:template&gt;


	&lt;!-- =========================================================== --&gt;
	&lt;!-- ISO/IEC 19757 - DSDL Document Schema Definition Languages   --&gt;
	&lt;!-- Part 4 - Namespace-based Validation Dispatching Language - NVDL --&gt;
	&lt;!-- Note: This does not include schemas referenced for          --&gt;
	&lt;!-- validation, it merely handles any simple XIncludes          --&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;!-- ISO/IEC 19757 - DSDL Document Schema Definition Languages   --&gt;
	&lt;!-- Part 8 - Document Schema Renaming Language - DSRL           --&gt;
	&lt;!-- Note: Final? Committee Draft   Experimental support only    --&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;!-- XInclude support for id based references only, with 1 level --&gt;
	&lt;!-- of fallback.                                                --&gt;
	&lt;!-- =========================================================== --&gt;

	&lt;xslt:template mode="dsdl:go"
		match="xi:include[@href][not(@parseType) or @parseType ='xml']"&gt;
		&lt;!-- Simple inclusions only here --&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-xinclude = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;xsl:choose&gt;

					&lt;xsl:when test="contains( @href, '#')"&gt;
						&lt;xsl:message terminate="yes"&gt;
							Fatal error: Xinclude href contains fragment
							identifier #
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;


					&lt;xsl:when test="contains( @xpointer, '(')"&gt;
						&lt;xsl:message terminate="yes"&gt;
							Fatal error: Sorry, this software only
							supports simple ids in XInclude xpointers
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;xsl:when
						test="string-length( @href ) = 0 and string-length( @xpointer ) = 0"&gt;

						&lt;xsl:message terminate="yes"&gt;
							Fatal Error: Impossible URL in XInclude
							include
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when test="string-length( @href ) = 0"&gt;

						&lt;xslt:apply-templates mode="dsdl:go"
							select="//*[@xml:id= current()/@xpointer  ] | id( @xpointer)
              	| //*[@id= current()/@xpointer  ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;xsl:when
						test="string-length( @xpointer ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( @href,/ )" /&gt;
						&lt;xsl:variable name="theFragment_1"
							select="$theDocument_1//*[@xml:id= current()/@xpointer  ]
             
              | $theDocument_1//*[@id= current()/@xpointer  ]" /&gt;
						&lt;!-- removed
							| $theDocument_1/id( @xpointer)
							because it requires rebasing in XSLT1 and that would mess up the use of current()
						--&gt;


						&lt;!-- Allow one level of fallback, to another XInclude --&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:choose&gt;
								&lt;xsl:when test="xi:fallback"&gt;
									&lt;xsl:variable name="theDocument_2"
										select="document( xi:fallback[1]/xi:include[not(@parseType)
                    	 or @parseType='xml']/@href,/ )" /&gt;
									&lt;xsl:variable name="theFragment_2"
										select="$theDocument_2//*[@xml:id= current()/xi:fallback[1]/xi:include/@xpointer  ]
              				| $theDocument_2//*[@id= current()/xi:fallback[1]/xi:include/@xpointer  ]" /&gt;
									&lt;!-- removed 
										| $theDocument_2/id( xi:fallback[1]/xi:include/@xpointer)
										because it id() would need rebasing in XSLT1 and that would mess up use of current()
									--&gt;

									&lt;xsl:if
										test="not($theDocument_2)"&gt;

										&lt;xsl:message terminate="no"&gt;
											&lt;xsl:text&gt;Unable to open referenced included file and fallback
									file: &lt;/xsl:text&gt;
											&lt;xsl:value-of
												select="@href" /&gt;
										&lt;/xsl:message&gt;
									&lt;/xsl:if&gt;
								&lt;/xsl:when&gt;
								&lt;xsl:otherwise&gt;
									&lt;xsl:message terminate="no"&gt;
										&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
										&lt;xsl:value-of select="@href" /&gt;
									&lt;/xsl:message&gt;
								&lt;/xsl:otherwise&gt;
							&lt;/xsl:choose&gt;
						&lt;/xsl:if&gt;
						&lt;xsl:apply-templates select=" $theFragment_1"
							mode="dsdl:go" /&gt;
					&lt;/xsl:when&gt;

					&lt;!-- Document but no fragment specified --&gt;
					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_3"
							select="document( @href,/ )" /&gt;
						&lt;xsl:variable name="theFragment_3"
							select="$theDocument_3/*" /&gt;

						&lt;xsl:if test="not($theDocument_3)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;xsl:apply-templates select="$theFragment_3 "
							mode="dsdl:go" /&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xslt:template&gt;

	&lt;!-- =========================================================== --&gt;
	&lt;!-- W3C XLink 1.1 embedded simple links                        --&gt;
	&lt;!-- =========================================================== --&gt;
	&lt;xslt:template
		match="*[@xlink:href][not(parent::*[@xlink:type='complex'])]
	           [not(@xlink:type) or (@xlink:type='simple')]
	           [@xlink:show='embed']
	           [not(@xlink:actuate) or (@xlink:actuate='onLoad')]"
		mode="dsdl:go" priority="1"&gt;

		&lt;xsl:variable name="document-uri"
			select="substring-before(concat(@xlink:href,'#'), '#')" /&gt;
		&lt;xsl:variable name="fragment-id"
			select="substring-after(@xlink:href, '#')" /&gt;
		&lt;xsl:processing-instruction name="DSDL_INCLUDE_START"&gt;
			&lt;xsl:value-of select="@xlink:href" /&gt;
		&lt;/xsl:processing-instruction&gt;
		&lt;xsl:choose&gt;
			&lt;xsl:when test="not( $include-xlink = 'true' )"&gt;
				&lt;xslt:copy&gt;
					&lt;xslt:copy-of select="@*" /&gt;
					&lt;xslt:apply-templates mode="dsdl:go" /&gt;
				&lt;/xslt:copy&gt;
			&lt;/xsl:when&gt;
			&lt;xsl:otherwise&gt;
				&lt;xsl:choose&gt;

					&lt;xsl:when
						test="string-length( $document-uri ) = 0 and string-length( $fragment-id ) = 0"&gt;
						&lt;xsl:message&gt;
							Error: Impossible URL in XLink embedding
							link
						&lt;/xsl:message&gt;
					&lt;/xsl:when&gt;

					&lt;!-- this case is when there is in embedded schema in the same document elsewhere --&gt;
					&lt;xslt:when
						test="string-length( $document-uri ) = 0"&gt;
						&lt;xslt:apply-templates mode="dsdl:go"
							select="//*[@xml:id= $fragment-id ] | id( $fragment-id) 
              	| //*[@id= $fragment-id ]" /&gt;
					&lt;/xslt:when&gt;

					&lt;xsl:when
						test="string-length( $fragment-id ) &amp;gt; 0"&gt;
						&lt;xsl:variable name="theDocument_1"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:if test="not($theDocument_1)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@xlink:href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;!-- use for-each to rebase id() to $theDocument --&gt;
						&lt;xsl:for-each select="$theDocument_1"&gt;
							&lt;xsl:variable name="theFragment_1"
								select="$theDocument_1//*[@xml:id= $fragment-id ]
               | id( $fragment-id ) 
               | $theDocument_1//*[@id= $fragment-id ]" /&gt;
							&lt;xsl:if test="not($theFragment_1)"&gt;
								&lt;xsl:message terminate="no"&gt;
									&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
									&lt;xsl:value-of select="@xlink:href" /&gt;
								&lt;/xsl:message&gt;
							&lt;/xsl:if&gt;
							&lt;xsl:apply-templates
								select=" $theFragment_1[1]" mode="dsdl:go" /&gt;
						&lt;/xsl:for-each&gt;
					&lt;/xsl:when&gt;

					&lt;xsl:otherwise&gt;
						&lt;xsl:variable name="theDocument_2"
							select="document( $document-uri,/ )" /&gt;
						&lt;xsl:variable name="theFragment_2"
							select="$theDocument_2/*" /&gt;

						&lt;xsl:if test="not($theDocument_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to open referenced included file: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@xlink:href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;

						&lt;xsl:if test="not($theFragment_2)"&gt;
							&lt;xsl:message terminate="no"&gt;
								&lt;xsl:text&gt;Unable to locate id attribute: &lt;/xsl:text&gt;
								&lt;xsl:value-of select="@xlink:href" /&gt;
							&lt;/xsl:message&gt;
						&lt;/xsl:if&gt;
						&lt;xsl:apply-templates select="$theFragment_2 "
							mode="dsdl:go" /&gt;
					&lt;/xsl:otherwise&gt;
				&lt;/xsl:choose&gt;

			&lt;/xsl:otherwise&gt;
		&lt;/xsl:choose&gt;

		&lt;xsl:processing-instruction name="DSDL_INCLUDE_END"&gt;
			&lt;xsl:value-of select="@xlink:href" /&gt;
		&lt;/xsl:processing-instruction&gt;
	&lt;/xslt:template&gt;


&lt;/xslt:stylesheet&gt;</value>
    <comment>Schematron transform - step 1 of 3</comment>
  </data>
  <data name="schematron_xslt_svrl" xml:space="preserve">
    <value>&lt;?xml version="1.0" ?&gt;
&lt;!-- 
   ISO_SVRL.xsl   

   Implementation of Schematron Validation Report Language from ISO Schematron
   ISO/IEC 19757 Document Schema Definition Languages (DSDL) 
     Part 3: Rule-based validation  Schematron 
     Annex D: Schematron Validation Report Language 

  This ISO Standard is available free as a Publicly Available Specification in PDF from ISO.
  Also see www.schematron.com for drafts and other information.

  This implementation of SVRL is designed to run with the "Skeleton" implementation 
  of Schematron which Oliver Becker devised. The skeleton code provides a 
  Schematron implementation but with named templates for handling all output; 
  the skeleton provides basic templates for output using this API, but client
  validators can be written to import the skeleton and override the default output
  templates as required. (In order to understand this, you must understand that
  a named template such as "process-assert" in this XSLT stylesheet overrides and
  replaces any template with the same name in the imported skeleton XSLT file.)

  The other important thing to understand in this code is that there are different
  versions of the Schematron skeleton. These track the development of Schematron through
  Schematron 1.5, Schematron 1.6 and now ISO Schematron. One only skeleton must be
  imported. The code has templates for the different skeletons commented out for 
  convenience. ISO Schematron has a different namespace than Schematron 1.5 and 1.6;
  so the ISO Schematron skeleton has been written itself with an optional import
  statement to in turn import the Schematron 1.6 skeleton. This will allow you to 
  validate with schemas from either namespace.
  

  History:
    2007-04-03 
    	* Add option generate-fired-rule (RG)
    2007-02-07
    	* Prefer true|false for parameters. But allow yes|no on some old for compatability
    	* DP Diagnostics output to svrl:text. Diagnosis put out after assertion text.
      	* Removed non-SVRL elements and attributes: better handled as an extra layer that invokes this one
      	* Add more formal parameters
      	* Correct confusion between $schemaVersion and $queryBinding
     	* Indent
     	* Validate against RNC schemas for XSLT 1 and 2 (with regex tests removed)
     	* Validate output with UniversalTest.sch against RNC schema for ISO SVRL
    	
    2007-02-01
       	* DP. Update formal parameters of overriding named templates to handle more attributes.
       	* DP. Refactor handling of rich and linkable parameters to a named template.

    2007-01-22
    	* DP change svrl:ns to svrl:ns-in-attribute-value
		* Change default when no queryBinding from "unknown" to "xslt"
	
    2007-01-18:
     	* Improve documentation
     	* KH Add command-line options to generate paths or not 
       	* Use axsl:attribute rather than xsl:attribute to shut XSLT2 up
       	* Add extra command-line options to pass to the iso_schematron_skeleton
  
    2006-12-01: iso_svrl.xsl Rick Jelliffe, 
          * update namespace, 
          * update phase handling,
          * add flag param to process-assert and process-report &amp; @ flag on output
  
    2001: Conformance1-5.xsl Rick Jelliffe, 
          * Created, using the skeleton code contributed by Oliver Becker
--&gt;
&lt;!--
 Derived from Conformance1-5.xsl.

 Copyright (c) 2001, 2006 Rick Jelliffe and Academia Sinica Computing Center, Taiwan

 This software is provided 'as-is', without any express or implied warranty. 
 In no event will the authors be held liable for any damages arising from 
 the use of this software.

 Permission is granted to anyone to use this software for any purpose, 
 including commercial applications, and to alter it and redistribute it freely,
 subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not claim
 that you wrote the original software. If you use this software in a product, 
 an acknowledgment in the product documentation would be appreciated but is 
 not required.

 2. Altered source versions must be plainly marked as such, and must not be 
 misrepresented as being the original software.

 3. This notice may not be removed or altered from any source distribution.
--&gt;

&lt;!-- Ideas nabbed from schematrons by Francis N., Miloslav N. and David C. --&gt;

&lt;!-- The command-line parameters are:
  			phase           NMTOKEN | "#ALL" (default) Select the phase for validation
    		allow-foreign   "true" | "false" (default)   Pass non-Schematron elements to the generated stylesheet
            diagnose= true | false|yes|no    Add the diagnostics to the assertion test in reports (yes|no are obsolete)
            generate-paths=true|false|yes|no   generate the @location attribute with XPaths (yes|no are obsolete)
            sch.exslt.imports semi-colon delimited string of filenames for some EXSLT implementations          
   		 optimize        "visit-no-attributes"     Use only when the schema has no attributes as the context nodes
		 generate-fired-rule "true"(default) | "false"  Generate fired-rule elements
            
--&gt;
&lt;xsl:stylesheet
version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"
xmlns:sch="http://www.ascc.net/xml/schematron"
xmlns:iso="http://purl.oclc.org/dsdl/schematron"
xmlns:svrl="http://purl.oclc.org/dsdl/svrl"
xmlns:exsl="http://exslt.org/common"
&gt;

  &lt;!-- Select the import statement and adjust the path as 
   necessary for your system.
   ### NOTE: iso_schematron_skeleton.xsl pasted in below to eliminate external references
   ###########################################################################################
--&gt;
  &lt;!-- This program implements ISO Schematron, except for abstract patterns which require a preprocess
 but also should handle schemas from most other versions of Schematron. --&gt;

  &lt;!-- To handle older schemas in different namespace, just
     comment out *one* only of these imports. --&gt;
  &lt;!--xsl:import href="skeleton1-6.xsl" /--&gt;
  &lt;!--xsl:import href="skeleton1-5.xsl" /--&gt;

  &lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;


  &lt;!-- Category: top-level-element --&gt;
  &lt;xsl:output method="xml" omit-xml-declaration="no" standalone="yes"  indent="yes"/&gt;



  &lt;xsl:param name="allow-foreign"&gt;false&lt;/xsl:param&gt;

  &lt;xsl:param name="message-newline"&gt;true&lt;/xsl:param&gt;

  &lt;xsl:param name="optimize" /&gt;

  &lt;!-- e.g. saxon file.xml file.xsl "sch.exslt.imports=.../string.xsl;.../math.xsl" --&gt;
  &lt;xsl:param name="sch.exslt.imports"/&gt;



  &lt;!-- Simple namespace check --&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:if  test="//sch:* and //iso:*"&gt;
      &lt;xsl:message&gt;Schema error: Schematron elements in old and new namespaces found&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:apply-templates /&gt;
  &lt;/xsl:template&gt;


  &lt;!-- ============================================================== --&gt;
  &lt;!-- ISO SCHEMATRON SCHEMA ELEMENT  --&gt;
  &lt;!-- Not handled: Abstract patterns. A pre-processor is assumed. --&gt;
  &lt;!-- ============================================================== --&gt;

  &lt;!-- SCHEMA --&gt;
  &lt;!-- Default uses XSLT 1 --&gt;
  &lt;xsl:template match="iso:schema[not(@queryBinding) or @queryBinding='xslt' 
     or @queryBinding='xslt1' or @queryBinding='XSLT' or @queryBinding='XSLT1'
     or @queryBinding='xpath']"&gt;
    &lt;xsl:if test="
	     @queryBinding='xslt1' or @queryBinding='XSLT' or @queryBinding='XSLT1'"&gt;
      &lt;xsl:message&gt;Schema error: in the queryBinding attribute, use 'xslt'&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;axsl:stylesheet&gt;
      &lt;xsl:apply-templates select="iso:ns"/&gt;
      &lt;!-- Handle the namespaces before the version attribute: reported to help SAXON --&gt;
      &lt;xsl:attribute name="version"&gt;1.0&lt;/xsl:attribute&gt;

      &lt;xsl:apply-templates select="." mode="stylesheetbody"/&gt;
      &lt;!-- was xsl:call-template name="stylesheetbody"/ --&gt;
    &lt;/axsl:stylesheet&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Using EXSLT with all modeles (except function module: not applicable) --&gt;
  &lt;xsl:template match="iso:schema[@queryBinding='exslt']" priority="10"&gt;
    &lt;xsl:comment&gt;This XSLT was automatically generated from a Schematron schema.&lt;/xsl:comment&gt;
    &lt;axsl:stylesheet
        xmlns:date="http://exslt.org/dates-and-times"
        xmlns:dyn="http://exslt.org/dynamic"
      xmlns:exsl="http://exslt.org/common"
      xmlns:math="http://exslt.org/math"
        xmlns:random="http://exslt.org/random"
        xmlns:regexp="http://exslt.org/regular-expressions"
        xmlns:set="http://exslt.org/sets"
        xmlns:str="http://exslt.org/strings"
        extension-element-prefixes="date dyn exsl math random regexp set str" &gt;

      &lt;xsl:apply-templates select="iso:ns"/&gt;
      &lt;!-- Handle the namespaces before the version attribute: reported to help SAXON --&gt;
      &lt;xsl:attribute name="version"&gt;1.0&lt;/xsl:attribute&gt;

      &lt;xsl:apply-templates select="." mode="stylesheetbody"/&gt;
      &lt;!-- was xsl:call-template name="stylesheetbody"/ --&gt;
    &lt;/axsl:stylesheet&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Using XSLT 2 --&gt;
  &lt;xsl:template match="iso:schema[@queryBinding='xslt2']" priority="10"&gt;
    &lt;axsl:stylesheet
       xmlns:xs="http://www.w3.org/2001/XMLSchema"
       xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	   &gt;
      &lt;xsl:apply-templates select="iso:ns"/&gt;
      &lt;!-- Handle the namespaces before the version attribute: reported to help SAXON --&gt;
      &lt;xsl:attribute name="version"&gt;2.0&lt;/xsl:attribute&gt;

      &lt;xsl:apply-templates select="." mode="stylesheetbody"/&gt;
      &lt;!-- was xsl:call-template name="stylesheetbody"/ --&gt;
    &lt;/axsl:stylesheet&gt;
  &lt;/xsl:template&gt;


  &lt;!-- Default uses XSLT 1 --&gt;
  &lt;xsl:template match="iso:schema" priority="-1"&gt;
    &lt;xsl:message terminate="yes" &gt;
      Fail: This implementation of ISO Schematron does not work with
      schemas using the "&lt;xsl:value-of select="@queryBinding"/&gt;" query language.
    &lt;/xsl:message&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="*" mode="stylesheetbody"&gt;
    &lt;!--xsl:template name="stylesheetbody"--&gt;
    &lt;xsl:comment&gt;
      Implementers: please note that overriding process-prolog or process-root is
      the preferred method for meta-stylesheets to use where possible. The name or details of
      this mode may change during 1Q 2007.
    &lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;

    &lt;xsl:call-template name="iso:exslt.add.imports" /&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;PHASES&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:call-template name="handle-phase"/&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;PROLOG&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:call-template name="process-prolog"/&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;KEYS&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:apply-templates mode="do-keys"   select="xsl:key  "/&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;DEFAULT RULES&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:call-template name="generate-default-rules" /&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;SCHEMA METADATA&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:call-template name="handle-root"/&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;SCHEMATRON PATTERNS&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*[not(self::iso:ns)]  "/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="iso:exslt.add.imports"&gt;
    &lt;xsl:param name="imports" select="$sch.exslt.imports"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="contains($imports, ';')"&gt;
        &lt;axsl:import href="{ substring-before($imports, ';') }"/&gt;
        &lt;xsl:call-template name="iso:exslt.add.imports"&gt;
          &lt;xsl:with-param name="imports" select="
                substring-after($imports, ';')"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="$imports"&gt;
        &lt;axsl:import href="{ $imports }"/&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="handle-phase" &gt;
    &lt;xsl:if test="not(normalize-space( $phase ) = '#ALL')"&gt;
      &lt;xsl:if test="not(iso:phase[@id = normalize-space( $phase )])"&gt;
        &lt;xsl:message&gt;
          Phase Error: no phase with name &lt;xsl:value-of select="normalize-space( $phase )"
		  /&gt; has been defined.
        &lt;/xsl:message&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="generate-default-rules"&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;MODE: SCHEMATRON-FULL-PATH&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;This mode can be used to generate an ugly though full XPath for locators&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;axsl:template match="*" mode="schematron-get-full-path"&gt;

      &lt;axsl:apply-templates select="parent::*" mode="schematron-get-full-path"/&gt;
      &lt;axsl:text&gt;/&lt;/axsl:text&gt;
      &lt;axsl:choose&gt;
        &lt;axsl:when test="namespace-uri()=''"&gt;
          &lt;axsl:value-of select="name()"/&gt;
        &lt;/axsl:when&gt;
        &lt;axsl:otherwise&gt;
          &lt;axsl:text&gt;*:&lt;/axsl:text&gt;
          &lt;axsl:value-of select="local-name()"/&gt;
          &lt;axsl:text&gt;[namespace-uri()='&lt;/axsl:text&gt;
          &lt;axsl:value-of select="namespace-uri()"/&gt;
          &lt;axsl:text&gt;']&lt;/axsl:text&gt;
        &lt;/axsl:otherwise&gt;
      &lt;/axsl:choose&gt;
      &lt;axsl:variable name="preceding" select=
    		"count(preceding-sibling::*[local-name()=local-name(current())
	  		                             and namespace-uri() = namespace-uri(current())])" /&gt;
      &lt;axsl:text&gt;[&lt;/axsl:text&gt;
      &lt;axsl:value-of select="1+ $preceding"/&gt;
      &lt;axsl:text&gt;]&lt;/axsl:text&gt;
    &lt;/axsl:template&gt;


    &lt;axsl:template match="@*" mode="schematron-get-full-path"&gt;
      &lt;axsl:apply-templates select="parent::*" mode="schematron-get-full-path"/&gt;
      &lt;axsl:text&gt;/&lt;/axsl:text&gt;
      &lt;axsl:choose&gt;
        &lt;axsl:when test="namespace-uri()=''"&gt;
          @&lt;xsl:value-of select="name()"/&gt;
        &lt;/axsl:when&gt;
        &lt;axsl:otherwise&gt;
          &lt;axsl:text&gt;@*[local-name()='&lt;/axsl:text&gt;
          &lt;axsl:value-of select="local-name()"/&gt;
          &lt;axsl:text&gt;' and namespace-uri()='&lt;/axsl:text&gt;
          &lt;axsl:value-of select="namespace-uri()"/&gt;
          &lt;axsl:text&gt;']&lt;/axsl:text&gt;
        &lt;/axsl:otherwise&gt;
      &lt;/axsl:choose&gt;
    &lt;/axsl:template&gt;

    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;

    &lt;xsl:comment&gt;MODE: SCHEMATRON-FULL-PATH-2&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;This mode can be used to generate prefixed XPath for humans&lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;!--simplify the error messages by using the namespace prefixes of the
     instance rather than the generic namespace-uri-styled qualification--&gt;
    &lt;axsl:template match="node() | @*" mode="schematron-get-full-path-2"&gt;
      &lt;!--report the element hierarchy--&gt;
      &lt;axsl:for-each select="ancestor-or-self::*"&gt;
        &lt;axsl:text&gt;/&lt;/axsl:text&gt;
        &lt;axsl:value-of select="name(.)"/&gt;
        &lt;axsl:if test="preceding-sibling::*[name(.)=name(current())]"&gt;
          &lt;axsl:text&gt;[&lt;/axsl:text&gt;
          &lt;axsl:value-of
            select="count(preceding-sibling::*[name(.)=name(current())])+1"/&gt;
          &lt;axsl:text&gt;]&lt;/axsl:text&gt;
        &lt;/axsl:if&gt;
      &lt;/axsl:for-each&gt;
      &lt;!--report the attribute--&gt;
      &lt;axsl:if test="not(self::*)"&gt;
        &lt;axsl:text/&gt;/@&lt;axsl:value-of select="name(.)"/&gt;
      &lt;/axsl:if&gt;
    &lt;/axsl:template&gt;

    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;MODE: GENERATE-ID-FROM-PATH &lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;!-- repeatable-id maker derived from Francis Norton's. --&gt;
    &lt;!-- use this if you need generate ids in separate passes,
		     because generate-id() is not guaranteed to produce the same
		     results each time. These ids are not XML names but closer to paths. --&gt;
    &lt;axsl:template match="/" mode="generate-id-from-path"/&gt;
    &lt;axsl:template match="text()" mode="generate-id-from-path"&gt;
      &lt;axsl:apply-templates select="parent::*" mode="generate-id-from-path"/&gt;
      &lt;axsl:value-of select="concat('.text-', 1+count(preceding-sibling::text()), '-')"/&gt;
    &lt;/axsl:template&gt;
    &lt;axsl:template match="comment()" mode="generate-id-from-path"&gt;
      &lt;axsl:apply-templates select="parent::*" mode="generate-id-from-path"/&gt;
      &lt;axsl:value-of select="concat('.comment-', 1+count(preceding-sibling::comment()), '-')"/&gt;
    &lt;/axsl:template&gt;
    &lt;axsl:template match="processing-instruction()" mode="generate-id-from-path"&gt;
      &lt;axsl:apply-templates select="parent::*" mode="generate-id-from-path"/&gt;
      &lt;axsl:value-of
			select="concat('.processing-instruction-', 1+count(preceding-sibling::processing-instruction()), '-')"/&gt;
    &lt;/axsl:template&gt;
    &lt;axsl:template match="@*" mode="generate-id-from-path"&gt;
      &lt;axsl:apply-templates select="parent::*" mode="generate-id-from-path"/&gt;
      &lt;axsl:value-of select="concat('.@', name())"/&gt;
    &lt;/axsl:template&gt;
    &lt;axsl:template match="*" mode="generate-id-from-path" priority="-0.5"&gt;
      &lt;axsl:apply-templates select="parent::*" mode="generate-id-from-path"/&gt;
      &lt;axsl:text&gt;.&lt;/axsl:text&gt;
      &lt;axsl:choose&gt;
        &lt;axsl:when test="count(. | ../namespace::*) = count(../namespace::*)"&gt;
          &lt;axsl:value-of select="concat('.namespace::-',1+count(namespace::*),'-')"/&gt;
        &lt;/axsl:when&gt;
        &lt;axsl:otherwise&gt;
          &lt;axsl:value-of
          select="concat('.',name(),'-',1+count(preceding-sibling::*[name()=name(current())]),'-')"/&gt;
        &lt;/axsl:otherwise&gt;
      &lt;/axsl:choose&gt;
    &lt;/axsl:template&gt;


    &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;MODE: GENERATE-ID-2 &lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
    &lt;!-- repeatable-id maker from David Carlisle. --&gt;
    &lt;!-- use this if you need generate IDs in separate passes,
		     because generate-id() is not guaranteed to produce the same
		     results each time. These IDs are well-formed XML NMTOKENS --&gt;
    &lt;axsl:template match="/" mode="generate-id-2"&gt;U&lt;/axsl:template&gt;

    &lt;axsl:template match="*" mode="generate-id-2" priority="2"&gt;
      &lt;axsl:text&gt;U&lt;/axsl:text&gt;
      &lt;axsl:number level="multiple" count="*"/&gt;
    &lt;/axsl:template&gt;

    &lt;axsl:template match="node()" mode="generate-id-2"&gt;
      &lt;axsl:text&gt;U.&lt;/axsl:text&gt;
      &lt;axsl:number level="multiple" count="*"/&gt;
      &lt;axsl:text&gt;n&lt;/axsl:text&gt;
      &lt;axsl:number count="node()"/&gt;
    &lt;/axsl:template&gt;

    &lt;axsl:template match="@*" mode="generate-id-2"&gt;
      &lt;axsl:text&gt;U.&lt;/axsl:text&gt;
      &lt;axsl:number level="multiple" count="*"/&gt;
      &lt;axsl:text&gt;_&lt;/axsl:text&gt;
      &lt;axsl:value-of select="string-length(local-name(.))"/&gt;
      &lt;axsl:text&gt;_&lt;/axsl:text&gt;
      &lt;axsl:value-of select="translate(name(),':','.')"/&gt;
    &lt;/axsl:template&gt;


    &lt;xsl:comment&gt;Strip characters&lt;/xsl:comment&gt;
    &lt;axsl:template match="text()" priority="-1" /&gt;

  &lt;/xsl:template&gt;

  &lt;xsl:template name="handle-root"&gt;
    &lt;!-- Process the top-level element --&gt;
    &lt;axsl:template match="/"&gt;
      &lt;xsl:call-template name="process-root"&gt;
        &lt;xsl:with-param
				name="title" select="(@id | iso:title)[last()]"/&gt;
        &lt;xsl:with-param name="version" select="'iso'" /&gt;
        &lt;xsl:with-param name="schemaVersion" select="@schemaVersion" /&gt;
        &lt;xsl:with-param name="queryBinding" select="@queryBinding" /&gt;
        &lt;xsl:with-param name="contents"&gt;
          &lt;xsl:apply-templates mode="do-all-patterns"/&gt;
        &lt;/xsl:with-param&gt;

        &lt;!-- "Rich" properties --&gt;
        &lt;xsl:with-param name="fpi" select="@fpi"/&gt;
        &lt;xsl:with-param name="icon" select="@icon"/&gt;
        &lt;xsl:with-param name="id" select="@id"/&gt;
        &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
        &lt;xsl:with-param name="see" select="@see" /&gt;
        &lt;xsl:with-param name="space" select="@xml:space" /&gt;
      &lt;/xsl:call-template&gt;
    &lt;/axsl:template&gt;


  &lt;/xsl:template&gt;

  &lt;!-- ============================================================== --&gt;
  &lt;!-- ISO SCHEMATRON ELEMENTS --&gt;
  &lt;!-- ============================================================== --&gt;

  &lt;!-- ISO ACTIVE --&gt;
  &lt;xsl:template match="iso:active"&gt;
    &lt;xsl:if test="not(@pattern)"&gt;
      &lt;xsl:message&gt;Markup Error: no pattern attribute in &amp;lt;active&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:if test="not(//iso:pattern[@id = current()/@pattern])"&gt;
      &lt;xsl:message&gt;
        Reference Error: the pattern  "&lt;xsl:value-of select="@pattern"
						   /&gt;" has been activated but is not declared
      &lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO ASSERT and REPORT --&gt;
  &lt;xsl:template match="iso:assert"&gt;

    &lt;xsl:if test="not(@test)"&gt;
      &lt;xsl:message&gt;Markup Error: no test attribute in &amp;lt;assert&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;		&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;
      ASSERT &lt;xsl:value-of select="@role" /&gt;
    &lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;

    &lt;axsl:choose&gt;
      &lt;axsl:when test="{@test}"/&gt;
      &lt;axsl:otherwise&gt;
        &lt;xsl:call-template name="process-assert"&gt;
          &lt;xsl:with-param name="test" select="normalize-space(@test)" /&gt;
          &lt;xsl:with-param name="diagnostics" select="@diagnostics"/&gt;
          &lt;xsl:with-param name="flag" select="@flag"/&gt;

          &lt;!-- "Rich" properties --&gt;
          &lt;xsl:with-param name="fpi" select="@fpi"/&gt;
          &lt;xsl:with-param name="icon" select="@icon"/&gt;
          &lt;xsl:with-param name="id" select="@id"/&gt;
          &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
          &lt;xsl:with-param name="see" select="@see" /&gt;
          &lt;xsl:with-param name="space" select="@xml:space" /&gt;

          &lt;!-- "Linking" properties --&gt;
          &lt;xsl:with-param name="role" select="@role" /&gt;
          &lt;xsl:with-param name="subject" select="@subject" /&gt;
        &lt;/xsl:call-template&gt;

      &lt;/axsl:otherwise&gt;
    &lt;/axsl:choose&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="iso:report"&gt;

    &lt;xsl:if test="not(@test)"&gt;
      &lt;xsl:message&gt;Markup Error: no test attribute in &amp;lt;report&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:text&gt;&amp;#10;&amp;#10;		&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;
      REPORT &lt;xsl:value-of select="@role" /&gt;
    &lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;

    &lt;axsl:if test="{@test}"&gt;

      &lt;xsl:call-template name="process-report"&gt;
        &lt;xsl:with-param name="test" select="normalize-space(@test)" /&gt;
        &lt;xsl:with-param name="diagnostics" select="@diagnostics"/&gt;
        &lt;xsl:with-param name="flag" select="@flag"/&gt;

        &lt;!-- "Rich" properties --&gt;
        &lt;xsl:with-param name="fpi" select="@fpi"/&gt;
        &lt;xsl:with-param name="icon" select="@icon"/&gt;
        &lt;xsl:with-param name="id" select="@id"/&gt;
        &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
        &lt;xsl:with-param name="see" select="@see" /&gt;
        &lt;xsl:with-param name="space" select="@xml:space" /&gt;

        &lt;!-- "Linking" properties --&gt;
        &lt;xsl:with-param name="role" select="@role" /&gt;
        &lt;xsl:with-param name="subject" select="@subject" /&gt;
      &lt;/xsl:call-template&gt;

    &lt;/axsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;!-- ISO DIAGNOSTIC --&gt;
  &lt;!-- We use a mode here to maintain backwards compatability, instead of adding it
	     to the other mode.
	--&gt;
  &lt;xsl:template match="iso:diagnostic" mode="check-diagnostics"&gt;
    &lt;xsl:if test="not(@id)"&gt;
      &lt;xsl:message&gt;Markup Error: no id attribute in &amp;lt;diagnostic&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="iso:diagnostic"  &gt;
    &lt;xsl:call-template name="process-diagnostic"&gt;

      &lt;!-- "Rich" properties --&gt;
      &lt;xsl:with-param name="fpi" select="@fpi"/&gt;
      &lt;xsl:with-param name="icon" select="@icon"/&gt;
      &lt;xsl:with-param name="id" select="@id"/&gt;
      &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
      &lt;xsl:with-param name="see" select="@see" /&gt;
      &lt;xsl:with-param name="space" select="@xml:space" /&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO DIAGNOSTICS --&gt;
  &lt;xsl:template match="iso:diagnostics" &gt;
    &lt;xsl:apply-templates mode="check-diagnostics" select="*" /&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO DIR --&gt;
  &lt;xsl:template match="iso:dir"  mode="text" &gt;
    &lt;xsl:call-template name="process-dir"&gt;
      &lt;xsl:with-param name="value" select="@value"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO EMPH --&gt;
  &lt;xsl:template match="iso:emph"  mode="text"&gt;

    &lt;xsl:call-template name="process-emph"/&gt;

  &lt;/xsl:template&gt;

  &lt;!-- ISO EXTENDS --&gt;
  &lt;xsl:template match="iso:extends"&gt;
    &lt;xsl:if test="not(@rule)"&gt;
      &lt;xsl:message&gt;Markup Error: no rule attribute in &amp;lt;extends&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="not(//iso:rule[@abstract='true'][@id= current()/@rule] )"&gt;
      &lt;xsl:message&gt;
        Reference Error: the abstract rule  "&lt;xsl:value-of select="@rule"
					/&gt;" has been referenced but is not declared
      &lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="IamEmpty" /&gt;

    &lt;xsl:if test="//iso:rule[@id=current()/@rule]"&gt;
      &lt;xsl:apply-templates select="//iso:rule[@id=current()/@rule]"
    mode="extends"/&gt;
    &lt;/xsl:if&gt;

  &lt;/xsl:template&gt;

  &lt;!-- KEY: ISO has no KEY --&gt;
  &lt;!-- NOTE: 
	     Key has had a checkered history. Schematron 1.0 allowed it in certain places, but
	     users came up with a different location, which has now been adopted. 
	     
	     XT, the early XSLT processor, did not implement key and died when it was present. 
	     So there are some versions of the Schematron skeleton for XT that strip out all
	     key elements.
	     
	     Xalan (e.g. Xalan4C 1.0 and a Xalan4J) also had a funny. A fix involved making 
	     a top-level parameter called $hiddenKey and then using that instead of matching
	     "key". This has been removed.
	--&gt;
  &lt;xsl:template  match="xsl:key" mode="do-keys" &gt;
    &lt;xsl:if test="not(@name)"&gt;
      &lt;xsl:message&gt;Markup Error: no name attribute in &amp;lt;key&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="not(@path) and not(@use)"&gt;
      &lt;xsl:message&gt;Markup Error: no path or use attribute in &amp;lt;key&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="parent::iso:rule "&gt;
        &lt;xsl:call-template name="IamEmpty" /&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="@path"&gt;
            &lt;axsl:key match="{../@context}" name="{@name}" use="{@path}"/&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;axsl:key match="{../@context}" name="{@name}" use="{@use}"/&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:if test="not(@match) "&gt;
          &lt;xsl:message&gt;Markup Error: no path or use attribute in &amp;lt;key&gt;&lt;/xsl:message&gt;
        &lt;/xsl:if&gt;
        &lt;axsl:key&gt;
          &lt;xsl:copy-of select="@*"/&gt;
        &lt;/axsl:key&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xsl:key "  /&gt;
  &lt;!-- swallow --&gt;

  &lt;xsl:template match="iso:key "  &gt;
    &lt;xsl:message&gt;Schema error: The key element is not in the ISO Schematron namespace. Use the XSLT namespace.&lt;/xsl:message&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO INCLUDE --&gt;
  &lt;!-- Extend the URI syntax to allow # refererences --&gt;
  &lt;xsl:template match="iso:include"&gt;
    &lt;xsl:variable name="document-uri" select="substring-before(@href, '#')"/&gt;
    &lt;xsl:variable name="fragment-id" select="substring-after(@href, '#')"/&gt;

    &lt;xsl:choose&gt;
      &lt;xsl:when test="string-length( $fragment-id ) != 0"&gt;
        &lt;xsl:apply-templates select="document( $document-uri )//iso:*[@id= $fragment-id ]"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:apply-templates select="document( $document-uri )/*"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

  &lt;/xsl:template&gt;

  &lt;!-- ISO LET --&gt;
  &lt;xsl:template match="iso:let" &gt;
    &lt;xsl:if test="ancestor::iso:schema[@queryBinding='xpath']"&gt;
      &lt;xsl:message&gt;Warning: Variables should not be used with the "xpath" query language binding.&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;axsl:variable name="{@name}" select="{@value}"/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO NAME --&gt;
  &lt;xsl:template match="iso:name" mode="text"&gt;

    &lt;xsl:if test="@path"&gt;
      &lt;xsl:call-template name="process-name"&gt;
        &lt;xsl:with-param name="name" select="concat('name(',@path,')')"/&gt;
        &lt;!-- SAXON needs that instead of  select="'name({@path})'"  --&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="not(@path)"&gt;
      &lt;xsl:call-template name="process-name"&gt;
        &lt;xsl:with-param name="name" select="'name(.)'"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="IamEmpty" /&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO NS --&gt;
  &lt;!-- Namespace handling is XSLT is quite tricky and implementation dependent --&gt;
  &lt;xsl:template match="iso:ns"&gt;
    &lt;xsl:call-template name="handle-namespace" /&gt;
  &lt;/xsl:template&gt;

  &lt;!-- This template is just to provide the API hook --&gt;
  &lt;xsl:template match="iso:ns"  mode="do-all-patterns" &gt;
    &lt;xsl:if test="not(@uri)"&gt;
      &lt;xsl:message&gt;Markup Error: no uri attribute in &amp;lt;ns&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="not(@prefix)"&gt;
      &lt;xsl:message&gt;Markup Error: no prefix attribute in &amp;lt;ns&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="IamEmpty" /&gt;
    &lt;xsl:call-template name="process-ns" &gt;
      &lt;xsl:with-param name="prefix" select="@prefix"/&gt;
      &lt;xsl:with-param name="uri" select="@uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO P --&gt;
  &lt;xsl:template match="iso:schema/iso:p " mode="do-schema-p" &gt;
    &lt;xsl:call-template name="process-p"&gt;
      &lt;xsl:with-param name="class" select="@class"/&gt;
      &lt;xsl:with-param name="icon" select="@icon"/&gt;
      &lt;xsl:with-param name="id" select="@id"/&gt;
      &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="iso:pattern/iso:p " mode="do-pattern-p" &gt;
    &lt;xsl:call-template name="process-p"&gt;
      &lt;xsl:with-param name="class" select="@class"/&gt;
      &lt;xsl:with-param name="icon" select="@icon"/&gt;
      &lt;xsl:with-param name="id" select="@id"/&gt;
      &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Currently, iso:p in other position are not passed through to the API --&gt;
  &lt;xsl:template match="iso:phase/iso:p" /&gt;
  &lt;xsl:template match="iso:p " priority="-1" /&gt;

  &lt;!-- ISO PATTERN --&gt;
  &lt;xsl:template match="iso:pattern" mode="do-all-patterns"&gt;
    &lt;xsl:if test="($phase = '#ALL') 
	or (../iso:phase[@id= $phase]/iso:active[@pattern= current()/@id])"&gt;
      &lt;xsl:call-template name="process-pattern"&gt;
        &lt;!-- the following select statement assumes that
			@id | sch:title returns node-set in document order:
			we want the title if it is there, otherwise the @id attribute --&gt;
        &lt;xsl:with-param name="name" select="(@id | iso:title )[last()]"/&gt;
        &lt;xsl:with-param name="is-a" select="''"/&gt;

        &lt;!-- "Rich" properties --&gt;
        &lt;xsl:with-param name="fpi" select="@fpi"/&gt;
        &lt;xsl:with-param name="icon" select="@icon"/&gt;
        &lt;xsl:with-param name="id" select="@id"/&gt;
        &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
        &lt;xsl:with-param name="see" select="@see" /&gt;
        &lt;xsl:with-param name="space" select="@xml:space" /&gt;
      &lt;/xsl:call-template&gt;
      &lt;axsl:apply-templates select="/" mode="M{count(preceding-sibling::*)}"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="iso:pattern[@abstract='true']"&gt;

    &lt;xsl:message&gt;
      Schema implementation error: This schema has abstract patterns, yet they are supposed to be preprocessed out already
    &lt;/xsl:message&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Here is the template for the normal case of patterns --&gt;
  &lt;xsl:template match="iso:pattern[not(@abstract='true')]"&gt;

    &lt;xsl:if test="($phase = '#ALL') 
	          or (../iso:phase[@id= $phase]/iso:active[@pattern= current()/@id])"&gt;

      &lt;xsl:text&gt;&amp;#10;&amp;#10;&lt;/xsl:text&gt;
      &lt;xsl:comment&gt;
        PATTERN &lt;xsl:value-of select="@id" /&gt; &lt;xsl:value-of select="iso:title" /&gt;
      &lt;/xsl:comment&gt;
      &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;
      &lt;xsl:apply-templates /&gt;

      &lt;axsl:template match="text()" priority="-1" mode="M{count(preceding-sibling::*)}"&gt;
        &lt;!-- strip characters --&gt;
      &lt;/axsl:template&gt;
      &lt;xsl:choose&gt;
        &lt;!-- UNTESTED: simple test for when there are no attribute tests needed --&gt;
        &lt;xsl:when test=" $optimize = 'visit-no-attributes' "&gt;
          &lt;axsl:template match="node()"
                  priority="-2"
                  mode="M{ count(preceding-sibling::*) }"&gt;
            &lt;axsl:apply-templates select="node()"
                        mode="M{ count(preceding-sibling::*) }"/&gt;
          &lt;/axsl:template&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;

          &lt;axsl:template match="@*|node()"
                  priority="-2"
                  mode="M{ count(preceding-sibling::*) }"&gt;
            &lt;axsl:choose&gt;
              &lt;xsl:comment&gt;
                Housekeeping: SAXON warns if attempting to find the attribute
                of an attribute
              &lt;/xsl:comment&gt;
              &lt;axsl:when test="not(@*)"&gt;
                &lt;axsl:apply-templates select="node()"
                            mode="M{ count(preceding-sibling::*) }"/&gt;
              &lt;/axsl:when&gt;
              &lt;axsl:otherwise&gt;
                &lt;axsl:apply-templates select="@*|node()"
                            mode="M{ count(preceding-sibling::*) }"/&gt;
              &lt;/axsl:otherwise&gt;
            &lt;/axsl:choose&gt;
          &lt;/axsl:template&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;

    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO PHASE --&gt;
  &lt;xsl:template match="iso:phase" &gt;
    &lt;xsl:if test="not(@id)"&gt;
      &lt;xsl:message&gt;Markup Error: no id attribute in &amp;lt;phase&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO RULE --&gt;
  &lt;xsl:template match="iso:rule[not(@abstract='true')] "&gt;
    &lt;xsl:if test="not(@context)"&gt;
      &lt;xsl:message&gt;Markup Error: no context attribute in &amp;lt;rule&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt;&amp;#10;&amp;#10;	&lt;/xsl:text&gt;
    &lt;xsl:comment&gt;
      RULE &lt;xsl:value-of select="@id" /&gt;
    &lt;/xsl:comment&gt;
    &lt;xsl:text&gt;&amp;#10;&lt;/xsl:text&gt;

    &lt;axsl:template match="{@context}"
		priority="{4000 - count(preceding-sibling::*)}" mode="M{count(../preceding-sibling::*)}"&gt;
      &lt;xsl:call-template name="process-rule"&gt;
        &lt;xsl:with-param name="context" select="@context"/&gt;

        &lt;!-- "Rich" properties --&gt;
        &lt;xsl:with-param name="fpi" select="@fpi"/&gt;
        &lt;xsl:with-param name="icon" select="@icon"/&gt;
        &lt;xsl:with-param name="id" select="@id"/&gt;
        &lt;xsl:with-param name="lang" select="@xml:lang"/&gt;
        &lt;xsl:with-param name="see" select="@see" /&gt;
        &lt;xsl:with-param name="space" select="@xml:space" /&gt;

        &lt;!-- "Linking" properties --&gt;
        &lt;xsl:with-param name="role" select="@role" /&gt;
        &lt;xsl:with-param name="subject" select="@subject" /&gt;
      &lt;/xsl:call-template&gt;
      &lt;xsl:apply-templates/&gt;
      &lt;!-- RJ: is this really what we want to do here? --&gt;
      &lt;axsl:apply-templates select="@*|*|comment()|processing-instruction()" mode="M{count(../preceding-sibling::*)}"/&gt;
    &lt;/axsl:template&gt;
  &lt;/xsl:template&gt;


  &lt;!-- ISO ABSTRACT RULE --&gt;
  &lt;xsl:template match="iso:rule[@abstract='true'] " &gt;
    &lt;xsl:if test=" not(@id)"&gt;
      &lt;xsl:message&gt;Markup Error: no id attribute on abstract &amp;lt;rule&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="@context"&gt;
      &lt;xsl:message&gt;Markup Error: (2) context attribute on abstract &amp;lt;rule&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="iso:rule[@abstract='true']"
		mode="extends" &gt;
    &lt;xsl:if test="@context"&gt;
      &lt;xsl:message&gt;Markup Error: context attribute on abstract &amp;lt;rule&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO SPAN --&gt;
  &lt;xsl:template match="iso:span" mode="text"&gt;
    &lt;xsl:call-template name="process-span"&gt;
      &lt;xsl:with-param name="class" select="@class"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ISO TITLE --&gt;
  &lt;xsl:template match="iso:title" &gt;
    &lt;xsl:call-template name="process-title" /&gt;
  &lt;/xsl:template&gt;


  &lt;!-- ISO VALUE-OF --&gt;
  &lt;xsl:template match="iso:value-of" mode="text" &gt;
    &lt;xsl:if test="not(@select)"&gt;
      &lt;xsl:message&gt;Markup Error: no select attribute in &amp;lt;value-of&gt;&lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="IamEmpty" /&gt;

    &lt;xsl:choose&gt;
      &lt;xsl:when test="@select"&gt;
        &lt;xsl:call-template name="process-value-of"&gt;
          &lt;xsl:with-param name="select" select="@select"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise &gt;
        &lt;xsl:call-template name="process-value-of"&gt;
          &lt;xsl:with-param name="select" select="'.'"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

  &lt;/xsl:template&gt;


  &lt;!-- ============================================================== --&gt;
  &lt;!-- DEFAULT TEXT HANDLING  --&gt;
  &lt;!-- ============================================================== --&gt;
  &lt;xsl:template match="text()" priority="-1" mode="do-keys"&gt;
    &lt;!-- strip characters --&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="text()" priority="-1" mode="do-all-patterns"&gt;
    &lt;!-- strip characters --&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="text()" priority="-1" mode="do-schema-p"&gt;
    &lt;!-- strip characters --&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="text()" priority="-1" mode="do-pattern-p"&gt;
    &lt;!-- strip characters --&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="text()" priority="-1"&gt;
    &lt;!-- Strip characters --&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="text()" mode="text"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="text()" mode="inline-text"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ============================================================== --&gt;
  &lt;!-- UTILITY TEMPLATES --&gt;
  &lt;!-- ============================================================== --&gt;
  &lt;xsl:template name="IamEmpty"&gt;
    &lt;xsl:if test="count( * )"&gt;
      &lt;xsl:message&gt;
        &lt;xsl:text&gt;Warning: &lt;/xsl:text&gt;
        &lt;xsl:value-of select="name(.)"/&gt;
        &lt;xsl:text&gt; must not contain any child elements&lt;/xsl:text&gt;
      &lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="diagnosticsSplit"&gt;
    &lt;!-- Process at the current point the first of the &lt;diagnostic&gt; elements
       referred to parameter str, and then recurse --&gt;
    &lt;xsl:param name="str"/&gt;
    &lt;xsl:variable name="start"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="contains($str,' ')"&gt;
          &lt;xsl:value-of  select="substring-before($str,' ')"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:value-of select="$str"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:variable&gt;

    &lt;xsl:variable name="end"&gt;
      &lt;xsl:if test="contains($str,' ')"&gt;
        &lt;xsl:value-of select="substring-after($str,' ')"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:variable&gt;

    &lt;!-- This works with all namespaces --&gt;
    &lt;xsl:if test="not(string-length(normalize-space($start)) = 0)
  		and not(//iso:diagnostic[@id = $start])
		and not(//sch:diagnostic[@id = $start]) 
		and not(//diagnostic[@id = $start])"&gt;
      &lt;xsl:message&gt;
        Reference error: A diagnostic "&lt;xsl:value-of select="string($start)"
	/&gt;" has been referenced but is not declared
      &lt;/xsl:message&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:if test="string-length(normalize-space($start)) &gt; 0"&gt;
      &lt;xsl:text&gt; &lt;/xsl:text&gt;
      &lt;xsl:apply-templates
         select="//iso:diagnostic[@id = $start ]
        	| //sch:diagnostic[@id = $start ] 
            | //diagnostic[@id= $start ]"/&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:if test="not($end='')"&gt;
      &lt;xsl:call-template name="diagnosticsSplit"&gt;
        &lt;xsl:with-param name="str" select="$end"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;!-- It would be nice to use this but xsl:namespace does not
  allow a fallback --&gt;
  &lt;!--xsl:template name="handle-namespace" version="2.0"&gt;
   &lt;xsl:namespace name="{@prefix}" select="@uri"&gt;
&lt;/xsl:template--&gt;

  &lt;xsl:template name="handle-namespace"&gt;
    &lt;!-- experimental code from http://eccnet.eccnet.com/pipermail/schematron-love-in/2006-June/000104.html --&gt;
    &lt;!-- Handle namespaces differently for exslt systems, msxml, and default, only using XSLT1 syntax --&gt;
    &lt;!-- For more info see  http://fgeorges.blogspot.com/2007/01/creating-namespace-nodes-in-xslt-10.html --&gt;
    &lt;xsl:choose&gt;

      &lt;!-- Untested --&gt;
      &lt;!--xsl:when test="/iso:schema/@queryBinding = 'xslt2'"&gt;
             &lt;xsl:namespace name="{@prefix}" select="@uri"  version="2.0" /&gt;
         &lt;/xsl:when--&gt;

      &lt;xsl:when test="function-available('exsl:node-set')"&gt;
        &lt;xsl:variable name="ns-dummy-elements"&gt;
          &lt;xsl:element name="{@prefix}:dummy" namespace="{@uri}"/&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:variable name="p" select="@prefix"/&gt;
        &lt;xsl:copy-of select="exsl:node-set($ns-dummy-elements)
                                  /*/namespace::*[local-name()=$p]"/&gt;
      &lt;/xsl:when&gt;

      &lt;!-- Not tested yet       
    	&lt;xsl:when test="function-available('msxsl:node-set')"&gt;
      		&lt;xsl:variable name="ns-dummy-elements"&gt;
        		&lt;xsl:element name="{ $prefix }:e" namespace="{ $uri }"/&gt;
      		&lt;/xsl:variable&gt;
      		&lt;xsl:copy-of select="msxsl:node-set($ns-dummy-elements)/*/namespace::*"/&gt;
    	&lt;/xsl:when&gt;
        --&gt;

      &lt;xsl:when test="@prefix = 'xsl' "&gt;
        &lt;!-- Do not generate dummy attributes with the xsl: prefix, as these
                are errors against XSLT, because we presume that the output
                stylesheet uses the xsl prefix. In any case, there would already
                be a namespace declaration for the XSLT namespace generated
                automatically, presumably using "xsl:".
           --&gt;
      &lt;/xsl:when&gt;

      &lt;xsl:when test="@uri = 'http://www.w3.org/1999/XSL/Transform'"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Using the XSLT namespace with a prefix other than "xsl" in &lt;/xsl:text&gt;
          &lt;xsl:text&gt;Schematron rules is not supported &lt;/xsl:text&gt;
          &lt;xsl:text&gt;in this processor: &lt;/xsl:text&gt;
          &lt;xsl:value-of select="system-property('xsl:vendor')"/&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;

      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="{concat(@prefix,':dummy-for-xmlns')}" namespace="{@uri}" /&gt;

      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;


  &lt;/xsl:template&gt;

  &lt;!-- ============================================================== --&gt;
  &lt;!-- UNEXPECTED ELEMENTS --&gt;
  &lt;!-- ============================================================== --&gt;

  &lt;xsl:template match="iso:*"  priority="-2"&gt;
    &lt;xsl:message&gt;
      &lt;xsl:text&gt;Error: unrecognized element in ISO Schematron namespace: check spelling
			and capitalization&lt;/xsl:text&gt;
      &lt;xsl:value-of select="name(.)"/&gt;
    &lt;/xsl:message&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="*"  priority="-3"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test=" $allow-foreign = 'false' "&gt;
        &lt;xsl:message&gt;
          &lt;xsl:text&gt;Warning: unrecognized element &lt;/xsl:text&gt;
          &lt;xsl:value-of select="name(.)"/&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:copy-of select="." /&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="iso:*" mode="text" priority="-2" /&gt;
  &lt;xsl:template match="*" mode="text" priority="-3"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test=" $allow-foreign = 'false' "&gt;
        &lt;xsl:message&gt;
          &lt;xsl:text&gt;Warning: unrecognized element &lt;/xsl:text&gt;
          &lt;xsl:value-of select="name(.)"/&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:copy-of select="." /&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;

  &lt;!-- ============================================================== --&gt;
  &lt;!-- DEFAULT NAMED TEMPLATES --&gt;
  &lt;!-- These are the actions that are performed unless overridden --&gt;
  &lt;!-- ============================================================== --&gt;

  &lt;!-- no params --&gt;

  &lt;xsl:template name="process-dir"&gt;
    &lt;xsl:param name="value" /&gt;

    &lt;!-- We generate too much whitespace rather than risking concatenation --&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
    &lt;xsl:apply-templates mode="inline-text"/&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-emph"&gt;
    &lt;!-- We generate too much whitespace rather than risking concatenation --&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
    &lt;xsl:apply-templates mode="inline-text"/&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-name"&gt;
    &lt;xsl:param name="name"/&gt;

    &lt;!-- We generate too much whitespace rather than risking concatenation --&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
    &lt;axsl:value-of select="{$name}"/&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;

  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-span" &gt;
    &lt;xsl:param name="class" /&gt;

    &lt;!-- We generate too much whitespace rather than risking concatenation --&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
    &lt;xsl:apply-templates mode="inline-text"/&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-title" &gt;
    &lt;xsl:param name="class" /&gt;
    &lt;xsl:call-template name="process-p"&gt;
      &lt;xsl:with-param  name="class"&gt;title&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-value-of"&gt;
    &lt;xsl:param name="select"/&gt;

    &lt;!-- We generate too much whitespace rather than risking concatenation --&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
    &lt;axsl:value-of select="{$select}"/&gt;
    &lt;axsl:text&gt; &lt;/axsl:text&gt;
  &lt;/xsl:template&gt;

  &lt;!--
   ###########################################################################################
   ### NOTE: iso_schematron_skeleton.xsl pasted in above to eliminate external references
&lt;xsl:import href="skeleton1-5.xsl"/&gt;
&lt;xsl:import href="skeleton1-6.xsl"/&gt;
--&gt;

  &lt;xsl:param name="diagnose"&gt;true&lt;/xsl:param&gt;
  &lt;xsl:param name="phase"&gt;
    &lt;xsl:choose&gt;
      &lt;!-- Handle Schematron 1.5 and 1.6 phases --&gt;
      &lt;xsl:when test="//sch:schema/@defaultPhase"&gt;
        &lt;xsl:value-of select="//sch:schema/@defaultPhase"/&gt;
      &lt;/xsl:when&gt;
      &lt;!-- Handle ISO Schematron phases --&gt;
      &lt;xsl:when test="//iso:schema/@defaultPhase"&gt;
        &lt;xsl:value-of select="//iso:schema/@defaultPhase"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;#ALL&lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:param&gt;
  &lt;xsl:param name="generate-paths"&gt;true&lt;/xsl:param&gt;
  &lt;xsl:param name="generate-fired-rule"&gt;true&lt;/xsl:param&gt;
  &lt;!-- e.g. saxon file.xml file.xsl "sch.exslt.imports=.../string.xsl;.../math.xsl" --&gt;

  &lt;!-- Experimental: If this file called, then must be generating svrl --&gt;
  &lt;xsl:variable name="svrlTest" select="true()" /&gt;

  &lt;!-- ================================================================ --&gt;

  &lt;xsl:template name="process-prolog"&gt;
    &lt;axsl:output method="xml" omit-xml-declaration="no" standalone="yes"
      indent="yes"/&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Overrides skeleton.xsl --&gt;
  &lt;xsl:template name="process-root"&gt;
    &lt;xsl:param name="title"/&gt;
    &lt;xsl:param name="contents" /&gt;
    &lt;xsl:param name="queryBinding" &gt;xslt1&lt;/xsl:param&gt;
    &lt;xsl:param name="schemaVersion" /&gt;
    &lt;xsl:param name="id" /&gt;
    &lt;!-- "Rich" parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;

    &lt;svrl:schematron-output title="{$title}" schemaVersion="{$schemaVersion}" &gt;
      &lt;xsl:if test=" string-length( normalize-space( $phase )) &amp;gt; 0 and 
		not( normalize-space( $phase ) = '#ALL') "&gt;
        &lt;axsl:attribute name="phase"&gt;
          &lt;xsl:value-of select=" $phase " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates mode="do-schema-p" /&gt;
      &lt;xsl:copy-of select="$contents" /&gt;
    &lt;/svrl:schematron-output&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="process-assert"&gt;
    &lt;xsl:param name="test"/&gt;
    &lt;xsl:param name="diagnostics" /&gt;
    &lt;xsl:param name="id" /&gt;
    &lt;xsl:param name="flag" /&gt;
    &lt;!-- "Linkable" parameters --&gt;
    &lt;xsl:param name="role"/&gt;
    &lt;xsl:param name="subject"/&gt;
    &lt;!-- "Rich" parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;
    &lt;svrl:failed-assert test="{$test}" &gt;
      &lt;xsl:if test="string-length( $id ) &amp;gt; 0"&gt;
        &lt;axsl:attribute name="id"&gt;
          &lt;xsl:value-of select=" $id " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test=" string-length( $flag ) &amp;gt; 0"&gt;
        &lt;axsl:attribute name="flag"&gt;
          &lt;xsl:value-of select=" $flag " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;!-- Process rich attributes.  --&gt;
      &lt;xsl:call-template name="richParms"&gt;
        &lt;xsl:with-param name="fpi" select="$fpi"/&gt;
        &lt;xsl:with-param name="icon" select="$icon"/&gt;
        &lt;xsl:with-param name="lang" select="$lang"/&gt;
        &lt;xsl:with-param name="see" select="$see" /&gt;
        &lt;xsl:with-param name="space" select="$space" /&gt;
      &lt;/xsl:call-template&gt;
      &lt;xsl:call-template name='linkableParms'&gt;
        &lt;xsl:with-param name="role" select="$role" /&gt;
        &lt;xsl:with-param name="subject" select="$subject"/&gt;
      &lt;/xsl:call-template&gt;
      &lt;xsl:if test=" $generate-paths = 'true' or $generate-paths= 'yes' "&gt;
        &lt;!-- true/false is the new way --&gt;
        &lt;axsl:attribute name="location"&gt;
          &lt;axsl:apply-templates select="." mode="schematron-get-full-path"/&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;svrl:text&gt;
        &lt;xsl:apply-templates mode="text" /&gt;

        &lt;xsl:if test="$diagnose = 'yes' or $diagnose= 'true' "&gt;
          &lt;!-- true/false is the new way --&gt;
          &lt;xsl:call-template name="diagnosticsSplit"&gt;
            &lt;xsl:with-param name="str" select="$diagnostics"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:if&gt;
      &lt;/svrl:text&gt;
    &lt;/svrl:failed-assert&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-report"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:param name="test"/&gt;
    &lt;xsl:param name="diagnostics"/&gt;
    &lt;xsl:param name="flag" /&gt;
    &lt;!-- "Linkable" parameters --&gt;
    &lt;xsl:param name="role"/&gt;
    &lt;xsl:param name="subject"/&gt;
    &lt;!-- "Rich" parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;
    &lt;svrl:successful-report test="{$test}" &gt;
      &lt;xsl:if test=" string-length( $id ) &amp;gt; 0"&gt;
        &lt;axsl:attribute name="id"&gt;
          &lt;xsl:value-of select=" $id " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test=" string-length( $flag ) &amp;gt; 0"&gt;
        &lt;axsl:attribute name="flag"&gt;
          &lt;xsl:value-of select=" $flag " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;

      &lt;!-- Process rich attributes.  --&gt;
      &lt;xsl:call-template name="richParms"&gt;
        &lt;xsl:with-param name="fpi" select="$fpi"/&gt;
        &lt;xsl:with-param name="icon" select="$icon"/&gt;
        &lt;xsl:with-param name="lang" select="$lang"/&gt;
        &lt;xsl:with-param name="see" select="$see" /&gt;
        &lt;xsl:with-param name="space" select="$space" /&gt;
      &lt;/xsl:call-template&gt;
      &lt;xsl:call-template name='linkableParms'&gt;
        &lt;xsl:with-param name="role" select="$role" /&gt;
        &lt;xsl:with-param name="subject" select="$subject"/&gt;
      &lt;/xsl:call-template&gt;
      &lt;xsl:if test=" $generate-paths = 'yes' or $generate-paths = 'true' "&gt;
        &lt;!-- true/false is the new way --&gt;
        &lt;axsl:attribute name="location"&gt;
          &lt;axsl:apply-templates select="." mode="schematron-get-full-path"/&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;svrl:text&gt;
        &lt;xsl:apply-templates mode="text" /&gt;

        &lt;xsl:if test="$diagnose = 'yes' or $diagnose='true' "&gt;
          &lt;!-- true/false is the new way --&gt;
          &lt;xsl:call-template name="diagnosticsSplit"&gt;
            &lt;xsl:with-param name="str" select="$diagnostics"/&gt;
          &lt;/xsl:call-template&gt;
        &lt;/xsl:if&gt;
      &lt;/svrl:text&gt;
    &lt;/svrl:successful-report&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="process-diagnostic"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;!-- Rich parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;
    &lt;svrl:diagnostic-reference diagnostic="{$id}" &gt;
      &lt;xsl:if test="string($id)"&gt;
        &lt;xsl:attribute name="id"&gt;
          &lt;xsl:value-of select="$id"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:call-template name="richParms"&gt;
        &lt;xsl:with-param name="fpi" select="$fpi"/&gt;
        &lt;xsl:with-param name="icon" select="$icon"/&gt;
        &lt;xsl:with-param name="lang" select="$lang"/&gt;
        &lt;xsl:with-param name="see" select="$see" /&gt;
        &lt;xsl:with-param name="space" select="$space" /&gt;
      &lt;/xsl:call-template&gt;
      &lt;svrl:text&gt;
      &lt;/svrl:text&gt;
      &lt;xsl:apply-templates mode="text"/&gt;
    &lt;/svrl:diagnostic-reference&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-rule"&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:param name="context"/&gt;
    &lt;xsl:param name="flag"/&gt;
    &lt;!-- "Linkable" parameters --&gt;
    &lt;xsl:param name="role"/&gt;
    &lt;xsl:param name="subject"/&gt;
    &lt;!-- "Rich" parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;
    &lt;xsl:if test=" $generate-fired-rule = 'true'"&gt;
      &lt;svrl:fired-rule context="{$context}" &gt;
        &lt;!-- Process rich attributes.  --&gt;
        &lt;xsl:call-template name="richParms"&gt;
          &lt;xsl:with-param name="fpi" select="$fpi"/&gt;
          &lt;xsl:with-param name="icon" select="$icon"/&gt;
          &lt;xsl:with-param name="lang" select="$lang"/&gt;
          &lt;xsl:with-param name="see" select="$see" /&gt;
          &lt;xsl:with-param name="space" select="$space" /&gt;
        &lt;/xsl:call-template&gt;
        &lt;xsl:if test=" string( $id )"&gt;
          &lt;xsl:attribute name="id"&gt;
            &lt;xsl:value-of select=" $id " /&gt;
          &lt;/xsl:attribute&gt;
        &lt;/xsl:if&gt;
        &lt;xsl:if test=" string-length( $role ) &amp;gt; 0"&gt;
          &lt;xsl:attribute name="role"&gt;
            &lt;xsl:value-of select=" $role " /&gt;
          &lt;/xsl:attribute&gt;
        &lt;/xsl:if&gt;

      &lt;/svrl:fired-rule&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-ns"&gt;
    &lt;xsl:param name="prefix"/&gt;
    &lt;xsl:param name="uri"/&gt;
    &lt;svrl:ns-prefix-in-attribute-values uri="{$uri}" prefix="{$prefix}" /&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-p"&gt;
    &lt;xsl:param name="role"/&gt;
    &lt;xsl:param name="icon"/&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:param name="lang"/&gt;

    &lt;svrl:text&gt;
      &lt;xsl:apply-templates mode="text"/&gt;
    &lt;/svrl:text&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template name="process-pattern"&gt;
    &lt;xsl:param name="name"/&gt;
    &lt;xsl:param name="id"/&gt;
    &lt;xsl:param name="is-a"/&gt;

    &lt;!-- "Rich" parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;
    &lt;svrl:active-pattern &gt;
      &lt;xsl:if test=" string( $id )"&gt;
        &lt;axsl:attribute name="id"&gt;
          &lt;xsl:value-of select=" $id " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test=" string( $name )"&gt;
        &lt;axsl:attribute name="name"&gt;
          &lt;xsl:value-of select=" $name " /&gt;
        &lt;/axsl:attribute&gt;
      &lt;/xsl:if&gt;

      &lt;xsl:call-template name='richParms'&gt;
        &lt;xsl:with-param name="fpi" select="$fpi"/&gt;
        &lt;xsl:with-param name="icon" select="$icon"/&gt;
        &lt;xsl:with-param name="lang" select="$lang"/&gt;
        &lt;xsl:with-param name="see" select="$see" /&gt;
        &lt;xsl:with-param name="space" select="$space" /&gt;
      &lt;/xsl:call-template&gt;

      &lt;!-- ?? report that this screws up iso:title processing  --&gt;
      &lt;xsl:apply-templates mode="do-pattern-p"/&gt;
      &lt;!-- ?? Seems that this apply-templates is never triggered DP --&gt;
      &lt;axsl:apply-templates /&gt;
    &lt;/svrl:active-pattern&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Overrides skeleton --&gt;
  &lt;xsl:template name="process-message"/&gt;


  &lt;!-- =========================================================================== --&gt;
  &lt;!-- processing rich parameters. --&gt;
  &lt;xsl:template name='richParms'&gt;
    &lt;!-- "Rich" parameters --&gt;
    &lt;xsl:param name="fpi" /&gt;
    &lt;xsl:param name="icon" /&gt;
    &lt;xsl:param name="lang" /&gt;
    &lt;xsl:param name="see" /&gt;
    &lt;xsl:param name="space" /&gt;
    &lt;!-- Process rich attributes.  --&gt;
    &lt;xsl:if test="string($space)"&gt;
      &lt;axsl:attribute name="xml:space"&gt;
        &lt;xsl:value-of select="$space"/&gt;
      &lt;/axsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string($lang)"&gt;
      &lt;axsl:attribute name="xml:lang"&gt;
        &lt;xsl:value-of select="$lang"/&gt;
      &lt;/axsl:attribute&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

  &lt;!-- processing linkable parameters. --&gt;
  &lt;xsl:template name='linkableParms'&gt;
    &lt;xsl:param name="role"/&gt;
    &lt;xsl:param name="subject"/&gt;

    &lt;!-- ISO SVRL has a role attribute to match the Schematron role attribute --&gt;
    &lt;xsl:if test=" string($role )"&gt;
      &lt;axsl:attribute name="role"&gt;
        &lt;xsl:value-of select=" $role " /&gt;
      &lt;/axsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;!-- ISO SVRL does not have a subject attribute to match the Schematron subject attribute.
       Instead, the Schematron subject attribute is folded into the location attribute --&gt;
  &lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt;</value>
    <comment>Schematron transform - step 3 of 3</comment>
  </data>
</root>